# day15

Object 클래스
	
	2. toString()
		==> 자바는 주소를 내부적으로 사용하고 있다.
			 하지만, 주소를 사용자(개발자)에게 노출하진 않는다.
			 
			대신 주소를 출력하면
				"클래스이름@해쉬코드값"
			의 형태로 출력을 한다.
			
			참고 ]
				해쉬코드
				==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
					해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
					
			문제 ]
				주소를 출력하려고 하는 순간 
					==> Object obj = new Object();
						이 때 obj에는 Object 객체의 주소가 기억이 될 것이고
						System.out.println(obj);
						라는 명령으로 출력을 하게되면..
						이 때 toString()가 자동 호출이 되게 한다.
			
			결론 ]
				toStirng()는 주소를 출력할 때 자동 호출되어서
				출력할 내용을 만들어주는 함수이다.
				
				따라서
				우리는 만든 클래스를 출력할 때
				우리가 원하는 내용으로 고쳐써서(Override) 해서 사용하면 된다.
				
				참고 ]
					
					public void toString(String str){ // 오버 로딩 , 반환값을 바꾸고 매개변수리스트를 채웠다.
						System.out.println(str);
					}
					
	3. clone()
		==> 자기 자신을 깊은 복사해주는 함수
			
			주의 ]
				
				이 함수는 접근 지정자가 protected 이므로
				상속 받은 클래스나 같은 패키지의 클래스에서만 사용할 수 있다.
				
	4. hashCode()
		==> 자바는 주소를 노출하지 않기 위해서
			해쉬테이블을 이용해서 주소를 관리한다.
			 그 해쉬테이블의 주소를 관리하는 코드값을 알려주는 함수
=========================================================================================================

String 클래스와 StringBuffer 클래스의 차이점
	
	
	*** StrubgBuffer 의 append는 맨 뒤에 공백을 두어야 사용할 때 에러가 나지 않는다.
	
	 String 클래스는 문자열을 변경하게 되면
	매번 Heap 영역에 객체를 생성하게 되므로
	메모리 낭비가 극심해진다.
	 따라서 이렇게 문자열의 수정이 빈번한 경우에는
	SttringBuffer나 StringBuilder를 사용해서 처리해주는 것이 좋다.
	 단, StringBuffer나 StringBuilder를 사용해서 문자열 수정을 마치게 되면
	반드시 String 타입으로 변경시켜주는 것이 좋다.
	
	 <== 왜냐하면, JAVA에서 사용하는 거의 대부분의 함수들의 매개변수가
	 	String타입의 데이터를 입력해주길 원하기 때문이다.
	 
	 이 때 String 타입으로 변경시켜주는 함수가
	 	toString
	 함수이고 역시 Object 클래스의 toString() 함수를 오버라이딩 해놓은 함수이다.
	 
=========================================================================================================

숙제 ]
	
	String, StringBuffer, StringBuilder 소속의 함수 10 이상 조사하고 예제를 만들어 보세요.
	
=========================================================================================================

Math
	==> 주로 수학적인 기능을 처리하는 함수로 구성되어 있는 클래스
		모든 함수가 static이므로 굳이 new 시키지 않아도 사용이 가능한 함수들 이고
		이 클래스들은 new 시키지 못 하도록 해놓은 클래스이다.
=========================================================================================================

래퍼 클래스(Wrapper Class)
	
	==> 주소를 사용(래퍼런스 변수를 사용) 하는 곳에서 기본 데이터타입을 사용할 수 없는 문제가 생긴다. // ArrayList는 Object 타입인데 기본형은 여기에 집어넣을 수 없는 상황이 생긴다 ..
		이런 문제를 해결하기 위해서 만든 클래스를 래퍼 클래스 (Wrapper Class)라고 한다.
		
		예를 들어
			int를 주소(인스턴스)로 사용할 수 있도록 하기 위해 만든 클래스
		
		참고]
			자바는 Object를 중심으로 계층 구조화 해서
			클래스를 이용하도록 만드는 객체지향 언어이다.
			
			그러나 유일하게 기본데이터타입(Value Type)만큼은 객체지향 원리를 사용하지 않는다. // 한 마디로 객체가 아니다.
			따라서 다형성 구현에 문제가 발생한다.
		
		예를 들어서
			void abc(Object o){
			}
			==> 이 함수는 모든 내용을 처리하도록 만든 함수.
				그런데 유일하게 기본데이터타입은 사용할 수 없다. == 객체가 아니기 때문이다.
				
			그래서 이런 문제를 해결하기 위해서 만들어진 클래스가 Wrapper class 이다.

		종류 ]
			Boolean, Character, Byte, Short, Integer, Long, Float, Double ( 8가지 )
			
		참고 ]
			
			Boxing 과  UnBoxing
				
				Boxing		:	기본 데이터 타입을 객체타입으로 변환하는 것을 말한다.
				UnBoxing	:	객체타입을 기본데이터타입으로 변환하는 것을 말한다.
				
				따라서
				Wrapper Class란 Boxing과 UnBoxing을 해주기 위한 클래스 이다.
				 ==> 자바에 대한 이해가 필요한 단어
		참고 ]
			그런데 이제는 Boxing, UnBoxing을   몰라도 상관없다.
			<== 자바 버젼 1.4 이후 부터는 Boxing과 UnBoxing이 자동으로 처리되기 때문에
				단, ArrayList의 제너릭스에는 Boxing을 해야 한다.
	결론 ]
		자바는 내부적으로 모든 정보를 주소로(레퍼런스로) 통일해서 사용할 수 있다.
=========================================================================================================

java.util 패키지 소속의 유용한 클래스

	1. Objects
		==> 이 클래스는 100% static함수로만 구성되어있는 클래스
			클래스를 다룰 때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스이다.
			
			예 ]
				
				isNull(Object o)
				==> 객체에 내용이 있는지 확인하는 함수.
					다시 말해서 new 시킨 결과가 있는지 확인하는 함수
				
					Object obj; << try이후 new되거나 안되거나..
					
					try{
						실행명령..
						obj = new Object(); <= 만들어지거나 안만들어지거나
						실행명령...
					} catch(Exception e){}
					
		*****
		참고	]
		  null
			: 주소 변수에 주소가 없는 상태--
				이것은 찾아갈 대상이 없다는 말이고
				이 말은 이것을 아직 사용할 준비가 되어있지 않다 라는 말이다.
=========================================================================================================

Random Class
	==> 난수를 발생하는 클래스
		우리가 사용해오던 Math.random() 보다는 좀 더 다양한 형태의 난수를 발생할 수 있는 장이 있다.
			
	참고]
		seed 란?
			
			컴퓨터에서 난수를 발생하는 것은
			명령을 내리는 순간 실제로 난수가 발생하는 것은 아니다.
			이미 컴퓨터 내부에는 난수테이블이 존재하고
			컴퓨터는 그 테이블에서 순서대로 데이터를 꺼내서 주는 역할을 한다.
			
			seed란 난수테이블에서 난수를 꺼내는 위치를 말하는 용어다.
			
			그 위치를 정하는게 생성자 함수였다.
================================================================================================

Arrays 클래스
	==> 역시 100% static 함수로만 구성된 클래스
		배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
		
		예 ]
			sort()
				==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
=================================================================================================

*****
정규식 검사 ( 타 언어에서도 사용하는 문법이다 )

	==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
		
		예]
			주민등록번호는 6자리 - 7자리의 숫자로만 구성되어 있는가???
		또는, 아이디가 순수하게 숫자와 문자열로만 구성되어 있는가???
			  아이디가 최소 몇글자 이상으로 만들어져 있는가???
			  
	사용하는 클래스
			
			java.util.regex.Pattern
				==> 정규식 검사에 사용할 정규식 문법(패턴)을 지정할 클래스.
				
			java.util.regex.Matcher
				==> 정규식 검사를 실제로 실행할 클래스
				
	참고]
	
		정규식 문법]
			
			1. c[a-z]*
				==> 글자를 특정위치에 기술하면 반드시 그 위치에 해당 글자가 와야 한다.
					// 1. 맨 앞글자는 c로 시작해야한다는 뜻.
					// 2. [] 안에 기록하면 그 중 하나가 와야한다는 뜻.
					// 3. *는 바로앞에 지정한 글자가 0개 이상 올 수 있다.
				
				==> 소문자 c로 시작하는 문자열
				
			2.c[a-z]
				==> c로 시작하고 다음 글자는 반드시 알파벳 소문자여야 한다.
			
			3. c[a-zA-Z]
				==> c로 시작하고 알파벳이 다음에 와야한다.
			
			4. c[a-zA-Z0-9]
				==>  c로 시작하고 알파벳이나 숫자가 다음에 와야한다.
					( 이 경우는 줄여서 c\w 로 사용할 수도 있다.)
			
			5. .*
				==> .은 모든 문자(알파벳과 한글까지 포함한다.)를 의미한다.
				
				==> 무슨 글자가 와도 상관없다.
				
			6. c.
				==> 첫글자로 c가 와야하고 다음은 아무문자 '한 글자(한 개)'가 오면 된다.
			
			7. c.*
				==> c로 시작하고 다음은 아무문자가 0개 이상 오면 된다.
				
			8. c\.
				==> \.은 반드시 "."문자만 와야한다. --> 출력 : c.  으로 나온다.
				
			9. c\d
				==> \d는 숫자 문자를 의미
				==> 첫글자는 c로 시작하고 그 다음은 숫자중 하나...
				==> c[0-9]

참고 ]
	자바에서 문자열 데이터 안에 큰따옴표를 포함하고싶을 경우
	==>	"가나다"라마"바사"  ==> "가나다\"라마\"바사"
	==> 이런경우 사용하는 문자를 이스케이프 문자라 칭한다. (탈출문자)
		표현하고 싶은 기호에 역슬래쉬(\)를 붙여서 문자열에 포함시키는 방법이다.	
		
			10. c.*t		==> "abcd c$t abc" 시작부분을 지정해주지 않는다면, 이 형태가 중간에 생성되고 끝나는 지점에 없어도 true를 반환한다.
							==> ^c.*t$  --> "c asdfasfdsadfsafsfsa$%!#! t"  첫 시작은 c로 시작하는데, 마지막문자는 t로 끝나야 하고 가운데는 아무문자나 와도 된다.
				==> 첫글자는 c가 와야하고
					그 다음은 아무문자나 0개 이상 오면되고
					마지막은 t로 끝나야 한다.
					
			11. [b|c].*
				==> 첫글자는 b나 c가 와야하고
					그 이후는 아무문자나 0개 이상 오면 된다.
					[b|c] ==> [b-c] ==> [bc] // 대괄호 안에 문자를 나열하게 되면, 그중에 하나만 오면 된다
			
			12.	[^b|c]
				==>  ^ 는 NOT의 의미
					b 또는 c가 아닌 문자
					
			13. .*a.*
				==> a라는 문자가 포함된 문자열
				
			14. .*a.+
				==> * : 0개 이상
					+ : 1개 이상
			
			15. [b|c].{2} 
				==> {} 안의 숫자의 의미는 글자의 갯수를 의미
				==> b또는 c로 시작한 다음의 2글자가 오면 된다. (총 3자리 문자열)
				
			16. .{2, 3}
				==> {2, 3}은 글자수를 의미하는데
					 , 는 OR를 의미한다. 
					 ==> 2자리 글자수 또는 3자리 글자수를 의미한다.
	
	
	이 부분은 자바스크립트 문법
			17. ^c
				==> 문자열의 첫글자는 반드시 c로 시작해야 한다. 
				
			18. c$ 
				==> 문자열의 마지막 그자는 반드시 c로 끝나야 한다.
=================================================================================================
				
Scanner Class < 사용빈도가 적다~ 콘솔에서만 입력받을 것이면 쓰기도 한다. ( 다른 입력받는 방법도 있기때문에..)

	==> 외부장치를 이용해서 데이터를 받아들이기 위한 클래스 (파일이라는 외부장치이다)
		
		참고 ]
			원래 자바는 IO라는 개념을 이용해서 외부장치를 연결한다.
			그러다보니 간단한 테스트를 위해서도 IO처리를 해야하므로
			개발자는 매우 불편했었다.
			
			자바버젼 1.5 부터 만들어진 기능이다.
			
		생성자 함수
			==> 외부장치인 File이나 IO인 Stream을 넣어달라고 하고있따.
			
		참고 ]
			System.in
				==> 내부적으로 키보드와 연결한 스트림으로 만들어 놓은 것
					
					우리가
					Scanner sc = new Scanner(System.in);
					==> 키보드를 통해 입력받는 Scanner가 된 것이다.
=================================================================================================
**
StringTokenizer < 사용빈도가 있다. 임시 버퍼에 담는다는 것. (중요) 
	
	==> 하나의 문자열을 원하는 문자를 기준으로 나누는 기능을 가진 클래스
		
		사용이유 ]
			네트워크등을 이용하면
			여러개의 데이터가 한번에 들어올 수 있다.
			
		예]
			
			카톡을 하면
			카톡을 보낸사람, 보낸시간, 내용,...등이
			하나의 문자열로 구성되어서 한번에 들어온다.
			==> 이런 경우 각각의 데이터를 분리해서 처리해야할 것이다.
				보낸사람@보낸시간@내용
		
		생성방법]
			
			1.StringTokenizer(String str)
				==> 문자열을 공백을 기준으로 나누는 기능
			
			2. StringTokenizer(String str, String delim)
				==> 문자열을 지정한 문자를 (String delim을)기준으로 나누는 기능
				
			3. StringTokenizer(String str, String delim, Boolean returnDelims)
				==> 2번 + 구분문자도 하나의 문자로 처리한다.
			
		참고 ]
			분리된 결과는 임시 버퍼에 기억이 되어있다.
			따라서 이것은 특징이 한번 사용하면 버퍼에서 그 순간 지워버린다. // 데이터 버퍼에 넣어둔 뒤 꺼내게 되면 지워진다.
			따라서 한 번 사용하면 더 이상 사용할 수 없다. 
			***
			반드시 순서대로만 꺼내야 한다.
			
		주요함수]
			
			countTokens()
				==> 문자열을 나눈 결과 수를 반환해주는 함수 
			
			hasMoreElements() / hasMoreTokens() // Object 타입 / String 타입.
				==> 임시버퍼에 내용이 남아있는지 여부를 묻는 함수 // 결과값은 true | false
			
			nextElement() / nextToken()        // Element < Object 타입 , Token < String 타입.
				==> 데이터를 꺼내는 함수
			
--------------------------------------------------------------------------------------------------------------------------------

BigDecimal
	==> 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스
		
		주로 데이터베이스와 연동할 때
		오라클의 데이터는 number(숫자)
			이 숫자는 38자리까지 사용할 수 있다.
		이런 데이터를 자바에서는 처리할 수 없으므로
		이런 유형의 데이터를 처리하기 위해서 만들어진 클래스
		
		예]
			
			BigDecimal big = new BigDecimal("1234567890123456789012345678901234567");

---------------------------------------------------------------------------------------------------------------------------------

Date 클래스
	
	==> 날짜와 시간을 관리하는 클래스
		
		생성자 함수 ]
			
			Date()
				==> 현재 시스템의 날짜와 시간을 이용해서 관리해준다.
				
				나머지 생성자
					==> 지정한 날짜와 시간을 이용해서 관리
		참고]
			이 클래스는 Calendar 클래스가 버전업 되기 전 버전이므로
			자바쪽 에서는 Calendar클래스 사용을 권장하고 있다.
			하지만 아직도 Date클래스를 사용해야 하는 함수가 존재한다.
			
			따라서 인지하고 있어야 한다. 
			++ Deprecated 라는 단어가 붙은 함수는
				JAVA의 버전이 바뀌면 사라질 수 있는 함수이니
						다른 함수를 사용하길 권고하는 것이다.
---------------------------------------------------------------------------------------------------------------------------------

Calendar 클래스
	==> Date클래스를 버전업 시켜놓은 클래스.
		생성방법]
		
		**
		이 클래스는 생성자 함수를 감춰놓은 경우에 해당하므로
		스스로 new 시켜서 객체를 만들 수는 없고
		함수 중 속성이 static 이면서 반환값이 Calendar인 함수를 찾아서 객체를 사용해야 한다.
		
		Calendar car = new Calendar() ==> 안 됩니다
		Calendar car = Calendar.getInstance(); ==> 됩니다.
		
	주요함수 ]
		
		get(int field)
			==> 필요한 정보를 알려주는 함수
				이 함수는 (int field에) 알고자 하는 내용을 알려주면
				그 값에 대해서 알려주는 함수이다.
				
				중요 ]
					
					Calendar 클래스는
					각각의 변수가 무엇을 알기 위한 변수인지를 공부해 놓는 것이 좋다.
					
					Field Summery를 보세요 ( Field는 클래스가 갖고있는, 클래스의 바로아래 있는 소속되어있는 멤버변수, 또한 대문자는 상수이며 static은 new시키지 않고 사용할 수 있다는 걸 기억해두자)
					
		getTime()
			==> Calendar 클래스를 Date 클래스로 변환하는 함수
				
				실무에서는 Calendar 클래스를 이용해서 작업을 하다가
				필요하면 Date 클래스로 변환해서 사용할 필요가 생긴다.
				
				예]
				
					Calendar car = Calendar.getInstance();
					......
					Date d = car.getTime();
				
			참고 ]
				자바 API의 함수 이용 방법
				
					API의 함수를 보면 문자열(String)로 의미하는 내용을
					정수(int)로 입력해 달라는 함수가 많이 존재한다.
					이런 경우는 99%가 자기자신이 가진 그 문자열을 의미하는 숫자를 
					담아 놓은 변수를 가지고 있다.
					그 변수를 이용해서 처리하면 된다.
				예 ]
					JOptionPane.showConfirmDialog(Component parentComponent, Object message,
													String title, int optionType)
					
					==> int optionType은 이미 JOptionPane에서 정의 해놓은 사수가 존재하고
						그 상수를 입력해주면 된다.
						
-------------------------------------------------------------------------------------------------------
