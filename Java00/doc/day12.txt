#day12

------------------------------------------------------------------------------------------------------------------------------
참고 ]
	함수의 오버로딩(Overloading : 함수의 중첩)
	==> 클래스내에 동일한 이름 함수를 정의 방법
		함수를 준비된 데이터의 유형, 갯수에 맞게 호출할 수 있는 방법
------------------------------------------------------------------------------------------------------------------------------

*****
함수의 오버라이딩(Overriding : 함수의 재정의 )
==> 상속 관계에 잇는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ]
		
		0. 고쳐 쓸려는 함수를 가진 클래스를 상속 받아야 한다. // 전제조건
		
		1. 반드시 상위 클래스가 가진 함수의 원형과 동일한 형태로 만들어야 한다.
		
			참고]
				함수의 원형(Prototype)
					: 반환값 + 함수이름 + 매개변수리스트 << 이것들이 반드시 똑같아야한다 매개변수 리스트까지..
				
		2. 접근지정자는    (프라이빗 - > 생략된 경우 -> 프로텍티드 -> 퍼블릭)
			같거나 넓은 방향으로 해야 한다 .
			
		3. 예외처리는 같거나 좁은 방향으로 해야 한다.
		
	이렇게 오버라이딩을 하면 내부적으로 super(산위클래스)의 함수가 숨겨지고 재정의한 함수를 사용하게 된다.
	
	예]
		class Father{
			void abc(int a){}
		}
		
		class Son extends Father{
			void abc(float a){} 	==> 함수의 중첩(Overloading)
			 
			 void abc(int a){
			 	abc(a);		==>abc(int a)는 abc(a)로 abc(float a)를 호출하겠다는의미
			 						==> 함수의 재정의(Overriding)
			 }
		}
		
		
		참고]
			
			super
				==> this가 현재 실행중인 자기자신의 주소를 기억하는 변수이듯이
					super역시 예약된 변수중 하나이다.
					  자신의 상위클래스의 주소를 기억하는 예약된 변수이다.
					 
				사용목적]	// 함수는 클래스인스턴스를 따르고 변수는 변수인스턴스를 따라간다,  SUPER함수 : 상위클래스의 맨 위에 숨겨져있는 생성자함수를 불러온다는 예약어
					반드시 상위 클래스의 소속임을 밝혀야 하는 경우가 생길 때 사용한다.
					
----------------------------------------------------------------------------------------------------------------------------------------
Object 클래스 
	==> 자바로 만들어진 클래스의 '최상위' super 클래스의 역할을 하는 클래스.
		따라서 Java로 만들어진 모든 클래스는 Object가 제공하는 모든 기능(멤버 : 함수 + 변수)을 자동적으로 사용할 수 있게 된다.
		
	참고]
		이렇게 최상위 클래스를 만들어 놓은 이유는 ??
			계층추적을 원활히 하도록 하기 위해서...
			<== 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서.
			
	참고]
		Java로 만든 모든 class는 반드시 상위 클래스(super class)를 가지고 있다.
		우리가 이제까지 만든 모든 class역시 super class를 가지고있다.
		만약 강제로 super class를 지정하지 않으면( ==> extends xxx 라고 기술하지 않으면..)
		 묵시적으로 Object라는 class를 상속받아 만들어진다.
		 
***	
instanceof << 객체의 소속을 밝혀줄 때 사용하는 연산자. (if로 사용하면서 true & false 를 반환한다.)
	==> 특정 클래스를 new 시키면 주소가 만들어진다.
		그 주소가 어떤 클래스 소속의 주소인지 알아내는 연산자
		연산의 결과는 true(참) , false(거짓)으로 나오게 된다.
		
		형식]
			주소 instanceof 클래스이름
		
		의미]
			주소가 가르키고있는 위치의 내용이 지정한 클래스 소속인지를 물어보는 것.
		
	참고]
		소속이라는 개념은 
		is a 관계를 따져주는 것이다. // 하위클래스 is 상위클래스 (Son is Father)
		따라서 상속 관계를 따지는 개념이 소속이라는 것.
---------------------------------------------------------------------------------------------------------

package와 import
	
	package
		==> Java 프로그램(소스)가 들어있는 폴더를
			Java적인 용어로 부르는 말이다.
			
			Java는 오픈소스이다.
			 따라서 모든 사람이 자신이 만든 프로그램을 배포할 수 있고
			 그것을 모든 사람이 이용할 수 있는 프로그램이다.
			
			  그런데 클래스이름끼리 충돌이 날 수 있다.
			이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이
			바로 'package' 이다
			
			즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서
			프로그램을 만들도록 하는 것.
			
			결론]
				java 프로그램을 만들 때는 반드시
			     이 프로그램이 어떤 폴더에 저장되는지를 알려주도록 해 놓았다.
			
			명령 ]
				
				package 	폴더이름;
				
		참고 ]
			
			패키지 이름을 만드는 권장 사항이 존재한다.
				==> 자신이 사용하는 도메인을 거꾸로 쓴 후
					그 다음에 다시 폴더이름을 붙여라..
					
					예]
						www.increpas.com 에  score라는 폴더를 만들 때.
						
					패키지이름]
						com.increpas.www.score
------------------------------------------------------------------------------------------------------------

import
	
	==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 클래스를 사용할지를 명확히 밝혀주기 위한 명령
	
	예]
		sample/Test.class
		
		Test/Test.class
		
	형식 1]
		
		import	패키지경로.클래스이름;
		 ==> 지정한 폴더에 있는 클래스를 사용할 예정임을 밝혀두는 것.
		
		예]
			import java.util.Scanner;
	
	형식 2]
		import	패키지경로.*;
		 ==> 지정한 폴더에 있는 모든 클래스를 상용할 예정임을 밝혀주는 것.
		
		예]
			
			import java.util.*;
			 ==> java.util 패키지 소속의 모든 클래스를 사용할 예정임을 밝혀주는 것.
	
	참고]
		형식 2번 보다는 1번을 우선시 한다.
		
	참고] import 하지 않아도
		명시적으로 클래스이름 앞에 패키지이름을 붙여서 사용할 수도 있다.
	
		예]
		  java.util.Scanner sc = new java.util.Scanner(System.in);
		  	<==이렇게 써도 사용 가능하지만. 번거롭기 때문에 클래스 위에 소속을 밝혀주자
		  	
  **
     참고]
     	java.lang 패키지는 ( 기본적으로 사용해야할 것들이 들어있는 패키지,
     					 반드시 꼭 있어야 프로그램이 구현되는 것들이 들어있느 패키지 )
     	import 하지 않아도 사용할 수 있다.
     		<==JVM이 기본적으로 찾아보는 패키지 이기 때문이다. 
     	
      참고]
      import를 하게되면 해당 패키지만 선언하게 되는 것이다.
	     즉, 상위나 하위는 포함되지 않는다.
  
      a
      	AAA.java
      	CCC.java
      	b-------
      		|__ZZZ.java
      		|__YYY.java
      		
         위의 경우
         
        import a.*;
         ==> AAA.java, CCC.java는 사용할 수 있지만
         	 ZZZ.java와 YYY.java는 사용할 수 없다.
         	 
 	 static import
 	 ==> static멤버는 원칙적으로 클래스이름.멤버로 사용합니다.
 	 	
 	 	Math.PI
 	 	Math.random()
 	 	
 	 	이때 static 멤버 앞에 사용하는 클래스 이름도 생략할 수 있다.
 	 	 ==> 이처럼 static 멤버를 사용할 때 
 	 	 	 이름을 생략하도록 하는 방법이 static import이다.
 	 	 
 	 	형식]
 	 		import	static 패키지이름.클래스이름.*; 
 	 	
---------------------------------------------------------------------------------------------------------------
	
	final 속성
		
		1. final 클래스
			==> 이 속성이 붙은 클래스는
				더 이상 상속이 불가능한 클래스임을 밝혀주는 속성이다.
				 : 대표적으로 String class이다.
				 
				 따라서 기능을 추가 혹은 변경하지 말고
				 현재 기능 그대로만 이용하라는 의미의 클래스이다.
				 
		2. final 함수 [접근지정자][속성 : final][반환값타입] 함수이름.....
			==> 이 속성이 붙은 함수는
			Overriding(함수의 재정의)가 불가능한 함수이다.
			따라서 이 함수는 매우 중요한 함수이므로
			
			함부로 기능을 바꾸지 말고 헌재 기능 그대로 사용하라는 의미.
			
		3. final 변수  <== 선언과 초기화를 동시에 해야한다. 상수로 정의되기도 한다.
			==> 이 속성이 붙은 변수는 값을 수정할 수 없는 변수이다.
				즉, 현재 값을 유지해야만 하는 변수를 의미한다.
				
---------------------------------------------------------------------------------------------------------

접근지정자
	
	==> 내용을 누구까지 사용할 수 있는지를 지정하는 예약된 용어
		즉, 우리가 클래스를 만든다고 해서
		그 클래스가 모든 사람에게 공개되는 것은 아니다.
		클래스를 제작하는 사람이 사용 범위를 지정할 수 가 있다.
		
		예]
			class는 누구까지 이 클래스를 사용하게 할까??
			new 시킬 수 있도록 할까?
			
			변수는 누구까지 데이터를 읽거나 입력하게 할거냐??
			
	종류 ]
		1.private
			==> 절대로 다른 클래스에서는 사용할 수 없고
				오직 자신의 클래스 내에서만 사용할 수 있다.
				
		2. 생략 된 경우
			==> 같은 패키지 소속의 클래스에서만 사용할 수 있다.
			 
		3. protected
			==> 상속받은 하위클래스와 같은 패키지소속의 클래스에서만 사용가능하다
			 
		4. public
			==> 모든 곳에서 사용할 수 있다.
			
	참고 ]
		
		class에는 public 과 생략된 경우만 사용할 수 있다.
	
	참고 ]
		클래스의 접근 지정의 의미는	  ==> 클래스 자체를 사용할지 여부를 지정하는 것이 된다.
		 
		 생성자 함수의 접근지정자의 의미는 ==> 어디까지 new시킬 수 있는지를 의미한다.
		 
-----------------------------------------------------------------------------------------------------
	참고 ]
		객체지향 언어의 특징
			
			1. 상속
			2. 다형성 
			3. 은닉화 & 캡슐화  ==>> 벨류 오브젝트VO, VO class, 데이터를 넘겨줄때 쓰는 오브젝트라 해서 DTO. 라고들 부른다.
				==> 은닉화 : 다른 클래스에서 함부로 접근할 수 없게 해놓은 조치다. (private)
				==> 캡슐화 : 변수나 함수를 전부 private으로 감추어 놓았을 때(은닉화 된 상태.) 그것을 조작해서 사용할 수 있게 만들어 놓은 것.
							( 이렇게하면 private도 다른 클래스에서 사용 가능하게 할 수 있는 것이다.)
		
		형식]
		
			1. 데이터를 담을 변수의 접근지정자는  private 으로 한다. (은닉화)
			2. 데이터를 세팅하고 내보내주는 함수를 반드시 제작해야한다.
				==> 이 함수의 접근 지정자는 public으로 한다. (캡슐화)
				예]
					Getters and Setters옵션.
					
					public double getComm(){
						return comm;
					}	
					public void setComm(double comm){
					 this.comm = comm;
					}
								
			**==> 1번과 2번은 세트로 움직인다.
			
		단축키 ]
			은닉화 캡슐화를 쓸 때 set, get를 만드는 방법
			
			: 만들 지점을 클릭 한 후 . source -> Generate Getters and Setters 누르고 만들 변수를 클릭 후 Getter을 누른다.
-------------------------------------------------------------------------------------------
	
***
은닉화
	프로그램에 있어서 가장 중요한 요소는 데이터이다. (처음 학습할 때 데이터 타입부터 배우는 것처럼 데이터는 가장 중요한 요소이다.)
	즉, 변수가 프로그램에서의 핵심적인 요소가 되는 것이다.
	무경설 데이터를 유지할 수 있는 것이  가장 중요한 개념이 된다.
	
	은닉화란?
		변수를 사용자가 함부로 변경하지 못하도록 방지하는 기술을 은닉화라고 한다.
		( ==> 결점이 있는 데이터가 오지 못하도록)
	방법 ]
		1. 중요한 데이터가 기억될 변수는 접근지정자를 private 으로 처리한다.
			==> 이렇게 만들면 그 변수는 다른 사용자가 사용할 수 없게 된다.// 일단 같은 클래스에서만 사용이 가능하게 된다.
		2. 대신 이 변수의 값을 변경하거나, 값을 알 수 있는  통로를 만들어 놓습니다.
			<== 함수를 사용한다. (getters * setters)
---------------------------------------------------------------------------------------------

review ]
	
	함수의 Overriding 규칙]
		
		0. 상속을 받는다.
		1. 함수의 원형은 반드시 일치해야한다.
			(반환값 + 함수이름 + 매개변수리스트 ==> 함수의 원형) < 한글자도 틀리지 않고 동일해야 한다.
		2. 접근지정자는 같거나 넓은 방향으로 해야한다.
			
			접근지정자의 범위
				작은 쪽(private < 생략 된 경우 < protected < public)넓은 쪽
				
		3. 예외처리는 같거나 좁은 방향으로 해야한다.
------------------------------------------------------------------------------------
	
	함수의 Overloading 규칙]
		0. 클래스내에 같은 이름의 함수가 있어야한다.
		1. 함수의 매개변수리스트는 달라야한다.
		2. 반환값 유형과는 전혀 상관없다.
------------------------------------------------------------------------------------

다형성(多形性)
	==> 하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 기법.
	
	주소의 형변환(Casting)
	==> 원칙적으로 주소는 다른 형태의 형변환이 불가능하다.
		즉, 주소는 Heap형태에 따라서 결정이 되기 때문에
			Heap타입이 다르면 주소를 기억할 수 없다.
	
	예]
		int[] no1 = new float[5]; ==> X
		Test t = new sample(); ==> X
		
	 그런데,
	*****
	딱 한가지 경우에 한해서 주소의 형변환이 가능하다.
	 상속관계에 있는 클래스 끼리는 형변환이 가능하다.
	왜냐면
		is a 관계이기 때문에... 
		
		자동형변환
			하위클래스의 주소가 상위클래스의 변수에 기억되는 것은
			자동적으로 형변환이 됩니다.
			
		강제형변환
			상위클래스의 주소가 하위클래스의 변수에 기억되는 것은
			원칙적으로 불가능하며
			다만 강제적으로 형변환해주어야 한다.
		
	예]
		class Father{}
		
		class Son extends Father{}
		
		Son s = new Son();
		Father f = s; 			==> 자동형변환  ==> Father가 더 상위 클래스이기 때문이다.
		
		Father f1 = new Son();
		Son s1 = f1;			==> 불가능
		
		Father f1 = new Son();
		Son s1 = (Son) f1; 		==> 강제형변환을 해줘야한다.	
		
	다형성이란 ?
		 주소의 형변환 이론을 기반으로 하여
		상위 클래스의 주소를 이용해서 하위클래스를 이용할 수 있으며,
		상위 클래스의 주소를 이용하면 여러 하위 클래스를 다룰 수 있다.
		
-------------------------------------------------------------------------------------

	사용자 입장에서의 다형성...
		상위 클래스의 변수를 이용해서 하위클래스를 사용할 수 있다.
		라는 말이므로
		상위 클래스의 변수를 이용해서 하위클래스를 받아서 사용하면 된다.
	주의]
		이 때 주의사항은
			
			변수	: 레퍼런스 쪽을 사용하게 되고
				==> 따라서 변수는 함부로 건드리지 마세요.
				
				왜? <== 상위클래스에서 쓰는 변수는 왠만하면 쓰지 않는 것이 좋습니다.
					 하위클래스에서 쓰는 변수는 그 걸 쓰겠다는 의미이다.
					  결국 받을 때 상위클래스로 받으면 하위클래스에서 아무리 변경을 해놓아도
					  상위클래스로 반환을 할 것이기 때문에 만지지 말라는 것이다.
					  
					  즉, 하위클래스에서 상위클래스의 변수는 되도록이면 수정하지 않는 것이 좋다.
					  
			함수	: 인스턴스 쪽을 사용하게 된다.
				==> 맨 마지막에 Overriding한 함수를 호출하게 된다.
		따라서 어떤 함수가 Object를 매개변수로 가지고 있다면
		그 함수는 실행할 때 어떤 데이터를 입력하더라도 실행이 된다는 의미이다
		
		2. 어떤 함수가 상위 클래스를 반환값으로 가지고 있으면
			반드시 원하는 하위 클래스 형태로 형변환 해서 사용해야 한다.
			
		예] <== 칠판 설명.
			class Grand{
				num =10;
				abc();
			}
			
			class Father extends Grand{
				num = 20;
				abc(){
				...
				}
			}
			class Son extends Father{
				num ;
				abc();
				xyz();
			}
			
			여기서 
			Grand g = new Son();
			g.abc();			-> 함수는 Father에 있는 abc를 사용하게된다. 제일 마지막에 Overriding된 것을 사용하게 됨.
			g.num;				=> 변수는 Grand에 있는 걸 사용하게 된다.
			g.xyz();			=> 사용할 수 없다
			((Son)g).xyz();		=> 사용할 수 있게 만들어 놓은 것.
			
-----------------------------------------------------------------------------------------------

문제 2]
	
	학생의 이름, java, db, html, js, css, 총점, 평균
	을 저장할 클래스를 만들고
	5학생의 데이터를 입력해서 출력하세요.
	단, 변수는 은닉화 시키세요.

-----------------------------------------------------------------------------------------------

문제 3]
	Figure클래스를 정의하고
	상속받아서 삼각형, 사각형, 원의 클래스를 정의한 후
	
	1 ~ 3 까지의 정수를 랜덤하게 10개 만들어서
	1의 경우 삼각형
	2의 경우 사각형
	3의 경우 원
	을 배열에 넣고
	출력하세요.

