#day11

생성자 함수(Constructor)

	==> 클래스를 사용하기 위해서 new 시키는 순간 자동 실행되는 함수
	
		즉, 클래스를 new 한다는 개념은 Object(객체)로 만들어서 실행을 한다는 개념이다.
		따라서 이 때 실행된다는 개념은 결국 Object를 만드는 순간에 뭔가를 실행한다는 개념이다.
		
		이 것은  물건을 만들 때 필요한 무언가 조치를 해야 한다는 개념이 된다.
	==> 
			결론]
				객체를 실제로 만들기 위한 함수가 생성자 함수이다.
				
		클래스는 한 가지 목적을 달성하기 위해서 만들어진 프로그램의 단위이다.
		이 안에는 그 목적을 달성하기 위한 변수, 함수로 구성이 되어있다.
		하지만, 그 목적을 달성하기 위해서 가장 기본적으로 어떤 해줘야할 조치가 필요한 경우가 있을 것이다.
		
		예 ]
			String
				문자열을 관리하기 위한 목적으로 만들어진 클래스
				==> 문자열을 기억하고 있어야 한다.
					==> String(); 기본생성자 함수 호출<
						String(문자열); 문자배열로도 문자열 생성자함수를 만들 수 있다.
				
			FileOutputStream
				파일에 내용을 기록하기 위한 목적으로 만들어진 클래스
				==> 파일을 사용할 수 있도록 열어두어야 한다. => 파일의 내용을 메모리에 올려 둔다는 얘기다.
			
			Socket
				네트워크를 구성하기 위한 목적으로 만들어진 클래스
				==> 상대방과 접속은 이루어져야 할 것이다.
				
		프로그램은 프로그램답게 무언가를 처리하기 위해서는 기능(함수)가 필요하고
		위의 경우를 비추어보면 각각의 클래스는 객체가 되는 순간 그 클래스의 최소한의 일을 할 필요가 있다.
		
		바로 이런 일을 하기 위해서 만들어 놓은 함수를
			"생성자함수(constructor)"
		라고 부른다.
		
		즉, 우리가 생성자 함수를 만드는 이유는 ??
		만들고자 하는 클래스의 목적에 따라
		그 클래스가 해야할 가장 기본적인 일을 처리하기 위해 만드는 것이다.
		(	변수 초기화 해준다.	)
		
		생성자 함수 만드는 방법]
			
			규칙 ]
				
				1. 함수의 이름은 반드시 클래스의 이름과 대소문자까지 동일하게 만들어 주어야 한다.
				2. 반환값은 절대로 가지면 안되고 void라고 써도 안된다.
				3. 매개변수는 가질 수 있다.
				
			 예]
				[접근지정자] < 쓰지않아도 된다.
			  class Test{
			  	Test(){
			  		// 생성자 함수이다.
			  		이 안에 이 클래스가 해야할 가장 기본적인 내용을 코딩하면 된다.
			  	} //Constructor
			  	Test(int a){
			  		//매개변수가 있는 생성자 함수
			  	} //Constructor
			  	
			  	void Test(){} ==> 반환값 타입이 붙는 순간 일반함수가된다. 
		  	}//class
			  참고]
			  	생성자 함수는 오버로딩이 가능하다.
			  	
			  	==> 왜??
			  		필요하면 그 클래스가 기본적으로 해야할 일이 조금씩 달라질 수 있기 때문에...
			  	
			  	방법]
			  		매개변수의 갯수, 순서, 형태중 하나이상을 달리함으로써
			  		생성자 함수를 여러개 만들어 놓을 수 있다.
			  	
			  	문제]
			  		여러개의 생성자 함수가 있다는사실은 new시킬때 호출하는 생성자 함수를 선택할 수 있어야 한다.
			  		
			  		==> 우리가 new시키는 문법을 살펴보면 해답이 보인다.
			  			new 시키는 문접은 생성자 함수를 호출하는 문법이다.
			  			
			  		예]
			  			class Test{
			  				Test(){}
			  				Test(int a){}
			  			}
			  			
			  			==> 객체를 만들때는 
			  				
			  				new Test();   --OK.
			  				new Test(10); --OK.
			  				
			  				<== 두가지 모두 위에서 Test클래스에서  정의해놓은 생성자 함수이므로
			  					두가지 모두 객체를 만들 수 있다.
			  		결론]
			  			매개변수가 있는 생성자 함수를 호출하기 위해서는
			  			new 시킬때 매개변수에 필요한 데이터를 입력하면서
			  			new 시키면 된다.
			  			
			  참고]
			  	기본 생성자 함수(Default Constructor)
			  	==> 매개변수가 하나도 없는 생성자함수를 부르는 용어다.
			  	*****
			  	자바는 생성자 함수가 없어도 new명령으로 객체를 만들 수 있다.
			  	 하지만 이것은 생성자 함수를 이용하지 않는 것이 아니고
			  	'JVM'이 기본 생성자를 내부적으로 만들어준 후 
			  	이 생성자 함수를 호출하는 것이다.
			  	
			  	결국
			  		자바는 new 시킬 때 마다 반드시 생성자함수를 이용하게 된다.
			  	
			  	*****
			  	만약 개발자가 생성자 함수를 단 한개라도 정의를 하면( 만들면 )
			  	JVM은 기본 생성자함수를 만들어주지 않습니다.
			  	즉, 내부적으로 기본 생성자 함수를 만드는 경우는
			  	오직 개발자가 생성자함수를 한개라도 만들지지 않았을 때이다.
			  	
		생성자 함수 이용 방법]
		
			결론 ]
				생성자 함수는 그 클래스를 new 시킬 때 알려주는 함수이다.
				어떻게 객체를 만들지 알려주는 함수...
				
				따라서 생성자 함수가 요구하는 매개변수가 무엇인지 보면
				그 클래스를 객체로 생성할 수 있는 방법이 도출된다.
			  	
			참고 ]
				여분의 클래스를 만들 때는 그 클래스를 객체로 만들 수 있는 다양한 방식을
				생성자 함수를 이용해서 만들어주는 것이 좋다.
				
		**********
		참고]
			this()
			==> 생성자함수는 원칙적으로 개발자가 직접 호출할 수 없습니다. --> 뜻 : 생성자함수는 객체가 될 때 생성되니까 new라는 명령과 함께 실행되어야하는 함수.
				
				현재 생성자를 실행하는 도중에(다른 오버로딩된 생성자함수를 얘기한다.)
				다른 생성자를 강제로 호출하는 유일한 방법이다.
				
			***
			규칙]
				1. '반드시' 생성자 안에서만 사용해야한다.
					일반함수 안에서는 사용할 수 없다.
				2. '반드시' 생성자 함수의 첫줄, 첫 문장으로 사용해야 한다.
					이전에 다른 문장이 있으면 에러가 발생한다.
				
			왜 사용해야하는 가??
			
			 	==> 클래스는 한가지 목적을 가진 프로그램의 집합이다.
			 		물론 기본적인 작업이 조금은 달라질 수 있지만
			 		그 틀자체는 변하지 않을 것이다.
			 		
			 		예]
			 			Socket은 접속할 대상의 주소와 포트번호는 바뀌겠지만
			 			결론은 접속을 시도해야할 것입니다.
			 			
			 			String은 데이터의 형태가 달라지겠지만
			 			결론은 문자열을 만들어야 할 것이다.
			 			
			 		따라서 생성자 함수가 하는 기능은 거의 비슷할 것이다.
			 		기능이 비슷하다는 의미는 코딩 내용도 거의 동일하다는 말이다.
			 		
			 		그런데
		 			     생성자 함수가 여러개면 같은 코드의 내용이  중복되어서  들어가야 한다.
			 			이 작업을 조금이라도 단순화 시켜주기 위해서 생성자 끼리는 서로 필요하면
						상대방을 이용할 수 있게 만들어 놓은 기법이다.
			 								
---------------------나중에 배울 내용-------------------------------------
		접근지정자]
			좁은 범위 ------------------------넓은 범위
			프라이빗  -  생략된 경우  -  프로텍티드  -  퍼블릭.
			(Private) (Be omitted) (Protected) (Public)
			
			프라이빗 : 같은 클래스 내에서만 접근이 가능합니다.
				==> 다른 클래스에서 프라이빗으로 지정된 클래스를 읽지 못합니다.
				
			생략된 경우 : 같은 패키지 내에서는 모두 접근이 가능합니다.
				==> 디폴트(Default)라고 하는 경우가 있는데 엄연히 다르다.
				
			프로텍티드 : 지금하는 클래스가 다른 패키지에 있는 클래스를 상속받아서 만들게 된다.
				==> 그 패키지 + 현재 소속된 패키지 내부에있는 프로텍티드가 붙은 것을 모두 사용할 수 있다.
				
			퍼블릭 : 모든 범위에서 접근이 가능하다.
			
		class에는 딱 2가지 접근지정자를 사용합니다.
		
			1. public
			
			2. 생략된 경우
			
		class 작성하는 이유 : 무언가를 만들어놓고 어디서든 불러서 쓰려고 한다. 이 경우 public을 사용한다.
---------------------나중에 배울 내용-------------------------------------

------------------------------------------------------------------------------------------------------------

this
	==> 교과서적인 의미로
		현재 실행중인 오브젝트의 주소를 기억하는 약속된 변수
		
		이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수 
		즉, 개발자는 거으 사용하지 않는 변수
		
		규칙이 
			1. 모든 멤번느 사용할 때 반드시 앞에 주소가 있어야한다.
				멤버는 클래스 내의 함수는 변수를 부르는 말이다.
				
				그래서 new 를 시킨 후 그 주솔르 기억해 놓았다가	그 주솔르 이용해서 사용하는 것이다.
				
			2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
			
			3. 멤버 함수를 호출할 때는 무조건 주소값을 함수한테 알려주도록 약속을 했고
				함수는 this 변수를 준비한 후 함수를 호출할 때 알려준 주소를 기억하게 된다.
		
		참고]
			딱 한번 this를 개발자가 사용해야 하는 경우가 있는데
			그 경우가 가끔은 지역변수와 멤버변수가 이름을 동일하게 만드는 경우가 발생한다.
			이러면 그 함수는 지역변수를 우선 사용하게 된다
			따라서 멤버 변수는 데이터가 기억되지 않을 수 있게 된다.
			***
			이때 굳이 이 변수가 멤버 변수임을 명확하게 밝히고 싶은 경우가 발생하면 이 때 강제로 this 라고 써주면 된다.
------------------------------------------------------------------------------------------------------------------------------------------------

static 속성
	==> static 영역에 생겨지는 함수나 변수에 붙여주는 속성
	
	참고 ] 
		클래스, 함수, 변수를 만들 때 속성을 지정할 수 있다.
		 
		예 ]
			
			1. 클래스
			[접근지정자] [ 속성 ] class 클래스이름 {}
			
			2. 함수
			[접근지정자] [ 속성 ] 반환값타입  함수이름(매개변수리스트){}
			
			3. 변수
			[접근지정자] [ 속성 ] 데이터타입 변수이름;
			
	static영역의 특징은
		1. 프로그램이 실행되기 위해서  JVM이 로딩하는 순간 자동으로 생성되는 영역
			즉, 사용자가 특별히 만들어달라는 요청이 없어도 자동적으로 생기는 영역.
		
		***
		2. 한 번 생긴 변수나 함수는 두 번다시 생기지 않는다.
		
	static 변수
		==> static 영역에 만들어지는 변수
			
			형식]
				
				[접근지정자] static 데이터타입 변수이름;
			
			특징]
				
				1. 여러 오브젝트가 공동으로 사용하는 변수가 된다. (자동적으로)
					왜?
						오브젝트 100개를 만들어도 static 변수는 오직 한개이다..
					즉, 한 객체가 데이터를 바꾸면 다른 객체도 바뀐 데이터를 사용해야 한다.
					따라서
					static 변수는 객체의 멤버로서의 의미가 없다.
					더군다나 객체가 없어도 사용할 수 있다.
				2. new 시키지 않아도 사용할 수 있는 변수입니다.
					왜?
						이미 메모리에 올려져 있으므로..
				결론]
					사용 방법]
						클래스이름.변수이름;
						
						으로 사용하면 된다.
						
						
	static 함수
		==> 변수와 마찬가지로 static 영역에 생기는 함수를 얘기한다.
			따라서 객체가 없어도 사용할 수 있다.
			
			사용법 ] 
				
				클래스이름.함수이름();
				
			***
			특징]
				this를 사용할 수 없는 함수입니다.
				// this : 현재 실행중인 객체 자기자신을 나타내는 예약어
		***
		결론 ]
			static 함수 안에서는 static멤버만 사용할 수 있다.
			(메모리에 올려진 애들은 모-두 쓸 수 있다.)
			일반 함수 안에서는 일반 멤버와 static멤버 모두 사용할 수 있다.	
----------------------------------------------------------------------------------------------------
멤버 변수의 초기화

	==> 멤버 변수는 Heap 영역에 생기므로 자동 초기화가 된다.
		하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
		
	1. 명시적 초기화
		==> 변수를 선언하면서 값을 입력하는 방법
			가장 먼저 실행되는 방법
			
			예]
			  class Test{
			  	int no = 10; ==> 명시적 초기화가 된다.
			  }	
			  
	2. 초기화 블럭을 이용한 초기화
		==> 인스턴스 변수에 대해서만 가능한 방법이다.
			두번째로 실행되는 방법
			
			형식]
				블럭을 먼저 만들고...
				
				{
					이 안에서 데이터를 변수에 입력하는 방법
				}
			
			예]
				class Test{
					int no;
					
					{
						no = 10;
					}//초기화를 위해 만들어진 블럭이다.
				}
				
	3. static 블럭을 이용한 초기화
		==> 두번째와는 반대로 static변수에 한해서만 가능한 방법이다.
			두번재로 실행되는 방법
			
			형식 ]
				static {
					데이터 입력
				}		
				
			예	]
			 	class Test{
			 		static int no;
			 		static{
			 			no = 10;
			 		}
			 	}
			 	
	4. 생성자 함수를 이용한 초기화
		==> 가장 마지막에 실행되는 방법
			why - 결국 클래스는 안에 내용 다 읽고 생성자 함수를 제일 마지막에 읽을 것 이다.
			
			예]
			  
			  class Test{
			  	int no;
			  	
			  	public Test(){
			  		this.no = 10;
			  	}
			  }
			
=====================================================================================================

*****
상  속
   ==>  객체지향 언어의 핵심
   		이미 만들어진 클래스의 기능을 그대로 부여받아서
   		(함수, 변수를 그대로 복사 받아서)
   		새로운 클래스를 만드는 방법
   		
   		이 개념이 나타나게된 이유는  소프트웨어의 개발속도를 빠르게 하기위한 방법의 한가지이다.
   		
   		즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로...
   		
   		객체 지향 언어는 부품단위로(클래스) 프로그램을 만든 후
   		그 부품을 조립해서 원하는 결과를 얻어내는 언어이다.
   		
   		==>
   		어디서 부품을 구했는데 그 기능이  사용자 마음에  꼭 맞지 않으 수 있다.
   		그러면 처음부터 다시 만들어야 하는가???
   		라는 문제에 도달한다.
   		이 문제를 해결하기 위해서 마드는 방법이 상속이다.
   		
   		상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
   		일단 그 부품을 복사한 후
   			1. 없는 기능은 더 붙이고
   			2. 있는 기능에서 바꿀 내용만 바꾸자
   			
   		*
   		형식]
   			// extends를 사용해서 상속받을 클래스이름을 적어주자.
   			[접근지정자] [속성] class 클래스이름  extends 상속받을 클래스이름{
   			
   			}
   			
   		***
   		참고]
   			자바에서 상속은 오직 단일 상속만 가능합니다.
   			
   			예]
   				class Test{}
   				
   				class Test1{}
   				
   				class Exec extends Test, Test1{} <==안된다. 단일 상속만 가능하기 때문이다.
   				
   				class Exec extends Test{}
   				 또는
   				class Exec extends Test1{} 이처럼 단일상속으로 사용해주어야 한다.
   				
   		용어 정리]
   		
   			상속을 해준 클래스 - super class 또는 상위 클래스 , 부모클래스 라고 얘기한다.
			상속을 받은 클래스 - sub class 또는 하위 클래스, 자식클래스 라고  얘기한다.
			
			is a 	- 상속 관계에 있는 클래스를 부르는 용어
					의미 : 상속 관계에 있다.라는 표현이다.
					표기법 : (하위 클래스 is a 상위 클래스)			
						class Father{}
						
						class Son extends Father{}
						
						이때
						Son is Father의 관계가 성립한다 라고 얘기한다.
						
					Father 변수에 Son을 넣었다고 얘기하기도 한다.
						
			has a	- 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
					 
					 class Father{}
					 
					 class Son{
					 	Father f = new Father();
				 	 }
				 	 
				 	 Son has a Father 가 성립이 된다.
				 	
--------------------------------------------------------------------------------------------------

상속 관계에 있는 경우 생서자의 역할 .		// 생성자의 함수도 멤버중에 하나이다.
	
	하위 클래스가 생성되는 순간
	상위 클래스가 자동 생성이 된다. ===> 상위 클래스의 생성자 함수가 자동 호출이 된다.
	
	==> 생성되는 순간 생성자 함수가 호출되므로
		결국
			하위 클래스를 생성하면
			상위 클래스의 생성자 함수도 실행된다.
			
	결국 상위 클래스의 생성자 함수는 자동으로 호출되는 개념이다.
	자동 호출 되는 경우에는 무조건 기본 생성자만 이용하게 된다.
	
	*** 
	참고]
		(this 함수의 특징 : 생성자함수 안에서만 호출 할 수 있다)
		super()
			==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령...또는 용어
			
		특징 ]
			1. 반드시 생성자 함수 안에서만 사용할 수 있다.
			2. 반드시 첫줄 첫 문장으로만 사용해야 한다.
