#day17
	-- 이전에 배운 ~
	public class ArrayList<E>  : 배열을 다루기 위해 만든 클래스
	public final class Objects : 객체를 다루기 위해 만든 클래스
	-- 기억해야 할 ~
	
Collections Class
	==> 이것은 이름은 컬렉션이지만
		컬렉션은 아니고
		컬렉션을 이용할 때 필요한 부가적인 기능을 제공하는
		유틸리티적인 클래스이다.
		
		주의 ]
			컬렉션을 사용할 때
			List를 달라고 하면 ( 매개변수에 List타입으로 정의가 되어 있으면.)
			List 계열을 입력하면 된다.
			Set을 달라고 하면 Set계열을 입력하면 된다.
			Collection을 달라고 하는 경우는 List 또는 Set 계열중 하나를 입력하면 된다.
			Map을 달라고 하면 Map 계열을 주면 된다. 
			
		참고 ]
			일반적인 정렬은 오름차순 정렬을 하게 된다.
			만약 정렬방식을 변경하고자 한다면
			sort(List list, Comparator c)를 사용해야 한다.
			
			 // 정렬을 할 수 있게 만들어 주는 인터페이스가 두가지가 있다.
			  그 두가지를 어떻게 쓰는지에 달라진다.
			  - 비교 할 수 없는 객체 자신이 다른 것과 비교를 할 때 사용하는것이 
			 Comparable (비교가능한)
			  	비교할 수 있도록 해주는 ..	인터페이스
			  	Comparator (비교자) : 객관적인 정렬 기준
			  	--> day17.Sagak.java 
===================================================================================================

Set 계열
	특징 ]
		1. 입력한 순서대로 보관하고 있을 보장이 없다.(==> 입력순서를 보장 못한다.)
			( 나름의 규칙에 따라서 내부적으로 정렬해서 보관하기 때문이다. )
		2. 중복된 데이터는 한번만 저장한다.
			( 중복된 데이터가 입력될 때에는 ; 먼저 저장 된 데이터를 지우고 새로운 데이터로 교체한다. )
	
	종류 ]
		1. HashSet	
				==> HashCode 를 이용해서 정렬해서 보관하는 방식의 컬렉션이다.
					따라서 우리가. 상상하는 정렬은 이루어지지 않는다.
					
					HashSet(int initialCapacity, float loadFactor) // 생성자 중에 이 생성자가 있습니다.
					==> loadFactor은 해쉬코드값을 만드는 규칙에 사용할 상수값을 //Capacity 한 번에 담을 수 있는 크기,
					 				사용자가 지정하면서 해쉬테이블을 만들어 사용한다.
	
		  *****
			Set 계열은 데이터를 꺼내는 기능이 존재하지 않는다.
				==> 이유는 개발자는 데이터가 저장된 장소를 모르기 때문에.. // 해쉬코드를 갖고 작업하기 때문에 모를 수 밖에 없다.
					따라서 특정 위치를 지정하면서 데이터를 꺼낼 수 없다.
					따라서 Iterator로 변환해서 순서대로 꺼내서 사용하도록 하고 있다.
					
					
		2. TreeSet	
				==> 내부족으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가지고 있는 클래스이다.
					
					특징 ]
						우리가 상상하는 정렬 방식을 이용한다. (오름, 내림차순 정렬)
						
					생성 방법 ]
						생성자 함수가 이와같이 정의된다.
						
						TreeSet(Comparator comparator) // 인터페이스는 new 시킬 수 없고 상속받은 클래스를 이용해야 한다.
														// 무명 클래스로 상속받지않고 바로 new 시켜서 사용하는 방법
														
							==> 정렬 방식을 변경해서 TreeSet을 만든다.
							
							TreeSet(SortedSet<E> s)					--> java.util.TreeSet<E>
								==> TreeSet을 이용해서 다시 TreeSet을 만드는 방식 
		참고 함수]
			
			1. subSet()
				: 하나의 Set에 담긴 내용중에서 특정부분만 골라서 새로운 Set을 만드는 함수
			2. headSet(E toElement)
				: 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다
			3. tailSet(E fromElement)
				: 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다.
===================================================================================================
Map
	==> 하나의 데이터를 그 데이터를 구분 할 수 있는 키값과 한쌍으로 만들어서
		데이터를 기억하는 컬렉션의 일종
		그리고 상요할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 해 놓았다.
		
		Map 계열은
		많은 양의 데이터를 보관하는 용도보다는
		데이터를 쉽게 구분하여 사용할 목적으로 사용된다.
		
	HashTable / HashMap
		HashTable 이 이전버젼에서 나온 클래스이고
		HashMap 이 HashTable의 다음 버전으로 나온 클래스이다.
		HashMap을 사용하도록 권장하고 있다.
	
		내부적으로 키값을 해쉬테이블을 이용해서 정렬해 보관한다.
		
		주요함수
			put(Object key, Object value)
				==> 데이터를 입력하는 함수
			
			get(Object key)
				==> 필요한 데이터를 꺼내는 함수
			
		참고함수
			
			values()
				==> 데이터만 꺼내서 사용할 수 있다.
			keys()
				==> 키값만 꺼내서 사용할 수 있다.
				
			참고 ]
				keys()로 꺼낸 데이터는 Enumeration으로 반환한다.
				
				Enumeration
				==> 이 클래스는 Iterator의 구버젼이다.
					즉, 데이터를 순차적으로 꺼낼 수 있는 클래스이다.
			참고 ]
				HashMap에서는 키값만 꺼내는 함수가 keySet()으로 변경이 되었다.
			
			참고 ]
				entrySet()
					==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
						(물론 다른방식으로 꺼낼 수 있는 방법이 있지만..)
						==> 키값과 데이터를 Set으로 묶어주는 함수
					
				문제 ]
					Map은 항상 두개가 있어야 저장된다.
						Set은 오직 한개만 저장이 된다.
					따라서 어떻게 해서든지 키와 벨류를 하나로 묶어야 한다.
					그래야만 Set과 연동할 수 있다.
					
					이것을 해결하기 위해서 클래스(VO)가 존재한다. 
					그 클래스가 바로
						
						Map.Entry
					라는 클래스이다.
					이 클래스 안에는 key와 value 변수를 은닉화 (private) 시켜놓고
					이 변수를 사용할 수 있는 변수를 제공하고 있다.
					이 변수들과 이 함수들을 캡슐화 해놓은 클래스이다.
					-- > Key와 Values 한 쌍만 저장할 수 있는 VO라는 말이다.
					
		TreeMap
			== > TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
				이 때 정렬 기준은 키값을 이용해서 정렬하게 된다.
				따라서 키값이 정렬이 되지 않는 클래스를 사용할 수 없고
				필요하다면 정렬반식을 정해서 사용해야 한다.
				
				예를 들자면
					Temp abc(){
						.......
						int a = 10;
						String b = "우현우";
						Temp t = new Temp();
						t.a = a;
						t.b = b;
						return t;
					}
				==> 이처럼 클래스를 보면 가끔 무슨 기능을 필요로 해서 만들어지는 것이 아니고
					다만 여러개의 데이터를 하나로 묶기 위한 목적으로 만들어 놓은 클래스가 있다.
					
					class Temp{
						int a;
						String b;
					}
					==> 이런 클래스를 우리는 데이터 빈 클래스라고 하고
						Value Object(VO) 또는 DTO(Data Tranfer Object(라고 한다.
					
			참고]
				컬렉션 안에는 다시 컬렉션을 입력할 수 있다.	
				이유는 ?
					컬렉션 안에는 모든 클래스를 입력할 수 있으므로
						컬렉션클래스까지 저장이 가능하다.
------------------------------------------------------------------------------------------------------

Properties
	==> Map의 역할을 하는 클래스
		
		일반 Map과의 차이점은
			파일을(외부장치를) 이용해서 직접 데이터를 읽어서 Map처럼 저장할 수 있고
			Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장할 수 있다.
			
		문제점 ]
			파일의 내용을 읽을 때 엔코딩(encoding)이 되지 않는다.(한글처리 하지 못한다.)
			==> 한글 파일의 경우 파일 자체에서 인코딩을 하지 않으면
				내용이 한글인 경우 한글이 깨져서 들어온다.
			***	
			모든 내용이 문자열로 처리가 된다.
			만약 공백이 입력되면 공백도 문자열의 구성으로 간주가 되서 같이 처리하게된다.
			
			"abc"	"abc "< 전혀 다른 데이터다. properties는 파일로 구분이 되며 공백의 유무는 눈으로 확인되지 않는다.
				Map 처럼 처리할 것이기 때문에 맨 뒤에는 value가 오게되고 결국 value로 처리하게 될 것이며
					이처럼 공백에 의한 오류가 생기면 곤란한 경우가 생길 수 있다.
				
				교수님의 처리방법  : properties 요청내용하고 해당 요청이 왔을 때 실행된 클래스를 문자열로 정의를 한다. 한 파일안에서
						Map일 것이기 때문에 어떤 요청이 왔을 때 key값을 가지고 어떤걸 실행해야할 지 알것이다.
						이 때 class의 경로를 써놓는데 공백을 갖게되면 공백마저 클래스의 이름으로 간주하기 때문에 찾지 못할 경우가 생긴다.
						properties 파일은 주의를 기울여서 공백오류가 생기지 않도록 해야한다. 
			
		참고 ]
			한글이 포함된 파일을 properties에서 사용하기 위해서 인코딩 시키는 방법
			
				1. cmd 창을 연다.
				2. path를 JAVA_HOME으로 잡아준다.
				3. native2ascii기능을 이용해서 인코딩해주면 된다.
				
					형식 ]
						
						C:\Users\class02>cd %JAVA_HOME%
						
						C:\Program Files\Java\jdk1.9.0_241\bin>dir 
								==> native2ascii.exe를 확인한다.
						
						> native2ascii 현재파일 새로운파일
							==> 인코딩해서 새로운 파일을 만들어준다는 말
							
						예]
							> native2ascii	d:\sample.txt	d:\sample_ko.txt
						
				참고 ]
					
					properties 클래스는 오직 String 으로만 키값과 데이터를 처리해야 한다.
					
				참고 ]
					properties는 이외에도 또 하나의 특징을 가지고있는데
					현재 프로그램의 정보를 Map으로 자동 처리하는 기능을 가지고 있다.
-------------------------------------------------------------------------------------------------------

제너릭스	
	==> 컬렉션에 데이터를 입려갛ㄹ 때 입력하는 데이터의 타입을 미리 알려줌으로써
		꺼낼때 좀 더 편하게 (형변환없이) 꺼낼 수 있도록 해주는 것.
		
		<== 컬렉션에는 모든 데이터가 입력되는 동시에 Object 타입으로 자동형변환이 되어서 저장이 된다.
		
		형식 ]
			
			ArrayList<String> list = new ArrayList<String>();
			== > list 에는 반드시 문자열 데이터만 입력해야 한다. 라는 선언이다.
			
		참고]
			제너릭스는 전파되지 않는다.
			하나의 컬렉션이 제너릭스 선언이 되더라도
			그 컬렉션을 이용하는 다른 컬렉션에서도 제너릭스가 전파되지는 않는다.
			다시 선언해줘야 한다.
			
		참고 ]
			특수한 제너릭스
				
				원래 제너릭스는 특정 클래스만 입력받을 목적으로 사용된다.
				
			형식 ]
				
				<? super 클래스이름>
					==> 지정한 클래스를 포함해서 상위의 클래스를 모두 허락한다.
					
				예 ]
					
					ArrayList<? super ArrayList> list = new ArrayList<? super ArrayList>();
					
			<? extends 클래스이름>
				==> 지정한 클래스 포함 하위 클래스까지 허락 <클래스이름> 의 형식과 같은 개념...
				
			이 방법은 제너릭스 선언을 하지 않은 것과 동일한 효과이다.
-------------------------------------------------------------------------------------------------------
			
	어노테이션
		==> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종
			
			주로
				화면에 실제 보이는 실행이 아니고
				점검을 한다던지,
				선언적인 실행(이 클래스는xxx로 작동하세요...)
				의 의미를 가진 명령을 말한다.
				
		형식]
		
			@명령
-------------------------------------------------------------------------------------------------------
			