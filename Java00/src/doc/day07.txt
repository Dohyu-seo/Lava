#day 07

배열의 정렬
	
	치환정렬을 해서 정렬한다.
	이 때 방법은 처음부터 하나씩 꺼내고
	비교를 하는데 대상은 - 꺼낸 다음 데이터부터 끝까지 꺼내서 비교를 해서
	오름차순이라면 
		대상이(꺼내온 데이터가) 더 작다면 현재 데이터와 교체를 해주어야 한다.
	이 때 주의사항은
	현재 데이터에 데이터를 입력하는 순간
	기존 데이터는 사라질 것이고 찾을 방법이 없다.
	따라서 - 사라지기 전에 어딘가에 저장을 해 두어야 한다.
	
	
---------------------------------------------------------
# flag 기법

	==> 프로그램을 실행하다보면 두 가지 이상의 경우가 발생되는 순간이 존재한다.
		그 후에 어떤 경우가 발생이 되서 처리된 것인지 알아보는 기법
		
		예]
		  
		  for(){
		  	break; // 이 명령이 실행되면(1)이 실행 된다.
		  	(0)
		  }
		  (1)
		  ==> 이 부분은 for 명령이 정상적으로 종료된 후에 실행되는 부분이다.
		  
		  
		  문제]
		  	for바깥부분인(1) 부분은 실행할 때 정상적으로 종료되었는지?
		  	break; 명령을 만나서 종료되었는지?
		  	알 수 없다.
		  	
		  방법]
		 	시작하기 전에 변수를 만들어줍니다.
		 	변수에 특정데이터로 초기화를 시켜놓고 특정 순간이 발생하면 변수의 데이터를 변경을 시킨다.
		 	(break가 되기 바로 전에...)
		 	
		 	(1)부분에서는 변수의 값에 따라서 반복문이 정상적으로 모두 실행되었는지,
		 		아니면 중간에 중단이 되었는지 판단할 수 있다. 
		 		
--------------------------------------------------------------------------

배열의 복사 
	
	1. 얕은 복사
		==> 주소만 복사해주는 기법입니다.
			
			특징]
				데이터는 공유하므로 한 곳에서 수정하면
				다른곳에서도 수정된 데이터를 사용하게 됩니다.
			
			복사 방법]
				
				int[] num1 = new int[5]; -- 배열만들기
				...... //코딩
				
				int[] num2; --배열 주소를 담을 새 배열 변수선언 (복사본 담을 배열)
					  		--num2안에는 데이터를 기억할 수 없고 오직 주소만 기억할 수 있다.
				
				num2 = num1; -- num2 초기화 -- 얕은 복사다.
			참고]
				얕은 복사는, 지역변수는 그 지역에서만(해당 블럭에서만) 활동하므로
				다른 지역에서 Heap 영역의 데이터를 사용할 목적을 많이 사용되는 기법이다.
				
				다른지역에서 만든 Heap 영역의 데이터를
				다른 지역에서도같이 사용할 목적으로 많이 사용되는 기법이다.
				
	2. 깊은 복사
		==> 데이터까지 모두 복사해주는 기법입니다.
			==> 데이터가 복사되는 것은
				Heap 영역에 다른곳에 데이터가 한 번 더 존재한다는 의미이므로 
				데이터의 주소가 달라지게 되므로
				
			특징]
				복사된 데이터는 독립적으로 사용 된다.
				
			명령]
				System.arraycopy(#1, #2, #3, #4, #5); -- 매게변수 5개필요하다는 말
				
					#1 - 원본데이터의 주소를 입력해줘야함
					#2 - 원본데이터의 복사를 시작할 위치
					#3 - 복사 받을 배열의 주소를 얘기함
					#4 - 복사 받을 배열의 복사 입력 시작 위치
					#5 - 복사 받을 데이터의 갯수를 입력 
					
--------------------------------------------------------------------------
				배열은 데이터타입, 크기(사이즈)도 지정을 해줘야 사용이 가능했다. 또한 한 번 만든 배열은 사이즈를 수정할 수 없다. 
배열의 단점
	1. 	한 번 배열의 크기를 정하면 크기 조절이 불가능하다.
		예]
			int[] num = new int[10];
			//의미 : 정수 데이터를 10개 관리할 예정이다.
			// --> 정수 데이터가 11개를 관리를 해야된다면??
			// 원칙적으로 불가능하다.
			// 이 때 해결 방법은 깊은 복사를 해준다.
			
			int[] num2 = new int[20];
			// num2의 앞 부분에 깊은 복사로 데이터를 채워넣으면
			// 이후 10개를 더 저장해서 사용할 수 있는 상태가 된다.
			
	2. 같은 타입의 데이터만 입력할 수 있다.
	
		==> 주소는 Heap Type에 의해서 결정되고
			Heap Type이 다르면 사용할 수 없다.(호환이 안된다.)
			
		예]
			int[] no = new int[10];
			
			float[] no2;
			no2 = no;
--------------------------------------------------------------------------

String 배열
	
	 참고]
	 	
	 	String 역시 참조형 변수이다. 주소를 기억하고 있다.
	 		
	 	String str = "hong";
	 	이라고 정의를 하면
	 	
	 	str속에는 Heap에 만들어진 주소를 기억하고 있다.
	 	"hong"은 리터럴 풀에 기억이 된다.
	 	
	 참고]
	 	문자열 만드는 방법 1]

	 		String 변수이름 = "데이터";
	 		
	 	문자열 만드는 방법 2]
	 		
	 		String 변수이름 = new String("문자열데이터");
	 
	 차이점]
	 	두 주소는 저장되는 데이터는 같아도, 갖고있는 주소는 다르다 Heap주소와 literal pool의 주소.
	 	고로 ==(동등비교연산자)를 쓰면 주소만 비교했을 때
	 	Heap과 literal pool의 주소는 다르기때문에,== 는 false가 나오고
	 	Heap에 있는 주소와 literal pool에 있는 주소의 데이터를 비교하려면
	 	문자열.equals(문자열)로 비교해야한다. 
	
	***
	문자열은 변경이 자주 일어나는 문자열의 경우
	String 타입으로 만들지 않고
	StringBuffer 나 StringBuild타입으로 만들고 연산해서
	최종적으로 변경된 데이터를 String 타입으로 사용하는 것이 좋다.
	
		참고]
			레퍼런스 변수란?
			주소를 기억하는 변수를 의미한다.
			하지만, 프로그램에서 주소는 필요하지 않다.
			따라서 주소 변수는 데이터가 존재하는 위치를 알려줄 뿐이다.
			핵심은 데이터가 들어갈 메모리, 즉 실제 데이터가 더 중요하다. 
	
	문자열 배열 만들기
		
		String[] 변수이름;
		변수이름 = new String[길이];
		==> String[] 변수이름 = new String[길이];
		
		변수이름[index] = 문자열 데이터;
		
		문자열 배열도 초기화가 가능하다.
		String[] 변수이름 = {문자열1, 문자열2, 문자열3....};
		String[] 변수이름 = new String[]{문자열1, 문자열2, 문자열3....};
		
문자열에서 자주 사용하는 함수
		
	1. String은 필요에 따라서 문자배열로 변환해서 사용할 수 있다.
		
		함수]
			toCharArray() : 문자열을 문자배열로 반환해주는 함수입니다.
			
	2. charAt(위치값)
		: 해당 위치의 문자를 반환해주는함수
		
	3. indexOf(문자)
		: 문자열에서 해당 문자가 위치하는 위칫값을 반환
		
	4. length()
		: 문자열의 길이를 정수로 바환해주는 함수
	
	5. substring()
		: 문자열 중에서 원하는 문자열만 뽑아서 반환해주는 함수
		
		형식 1]
			substring(시작위치)
			==>시작위치에서 부터 멘 마지막까지 추출해서 반환해주는 함수
			
		형식 2] 	
			substring(시작위치, 종료위치)
			==> 시작 위치부터 종료위치까지 꺼내서 반환해주는 함수
			
			*
			주의]
				시작위치는 0부터 카운트를 하고 
				종료위치는 반환 문자열에서 제외되서 반환된다.
				종료위치 전 문자까지만 추출해서 반환해준다.
	
	6. equals(문자열)
		==> 문자열의 데이터가 같은 값인지 비교하는 함수
		특별하게 리터럴풀에 데이터를 직접 비교할 수 있다.
		형식]
			문자열1.equals(문자열2)
			==> 반환값은  boolean타입의 데이터(true || false)
--------------------------------------------------------------------------
반장님 문제]
	45 ~ 1 까지 저장할 배열을 만들고
	배열에서 로또 번호를 꺼내서 로또 한 게임을 만들고 출력하세요.
--------------------------------------------------------------------------

문제1]
	
	알파벳 10개를 저장할 배열을 만들고
	대문자 10개를 랜덤하게 추출해서 배열에 저장하고
	
	저장된 배열을 얕은복사로 복사해서
	출력을 하고,
	원 배열을 소문자로 변경한 후 두 배열을 출력하세요.
	
--------------------------------------------------------------------------

문제 2]
	정수 10개를 저장할 배열을 만들고
	랜덤하게 1 ~ 50까지 수중 발생을 시켜서
	배열에 담고 배열의 5번째까지의 데이터를 깊은복사로 복사하세요.
	배열 2개
--------------------------------------------------------------------------
문제 3]
	회원의 이름을 입력하면
	회원의 이름과 전화번호, 이메일을 저장할 배열을 만들고 - 문자3개
	
	이름을 입력하면 그 사람의 데이터를 모두 저장할 배열을 만들어서
	데이터를 넣고 출력하세요.		

--------------------------------------------------------------------------
문제 4]
	전화번호를 입력하면 '-'를 기준으로 데이터를 분리해서 저장할 배열을 만들고
	분리 된 데이터를 순서에 맞게 입력하고 출력하세요.
	indexOf();
	substring();
--------------------------------------------------------------------------

extra]
	영문 문자열을 입력받아서
	해당 알파벳이 출현하는 빈도를 저장하고
	빈도를 *로 표현하세요.	