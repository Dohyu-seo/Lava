# day18

------------------------------------------------------------------------------------------------------------------------------
스레드
	
	참고 ]
	
		자바가 프로그램을 실행시키는 방법
			
			1. Processor를 이용하는 방법
				==> 운영체제에 의해서 자신이 사용할 메모리를 할당 받고
					레지스트리에 등록한 후 실행되는 방식
				
				단점
					각각의 프로세스 프로그램은 원칙적으로
					자신의 데이터를 다른 프로세스 프로그램에게 주지 못한다.
					(메모리끼리 호환이 되지 않는다.)
						컨트롤C, V는 운영체제가 기억하고 있는 부분이기 때문에 다른 프로세서에서 이용이 가능하게 되는 것이다.
				
				우리가 지금까지 실행한 모든 자바 프로그램은 프로세스를 이용한 방식으로 실행되었다.
				( ==> 즉, main함수부터 시작하는 프로그램은 프로세스 방식을 실행하게 된다.)
								
			2. Thread를 이용하는 방법
				==> 독립적인 메모리를 할당받지 못하고 실행하는 프로그램이다.
					대신 프로세스 프로그램이 사용하는 메모리를 같이 공유하게 된다.
					
					참고 ] 
						스레드는 혼자서는 실행되지 못한다.
						반드시 다른 프로세스가 실행이 된 후 실행이 되어야 한다.
						(프로세스의 종속성)
					
					장점 ]
						 스레드 프로그램은 메모리를 같이 사용하므로
						 같은 메모리를 사용하는 프로그램끼리는 데이터 교환이 가능하다.
						 
용어정리
	
	1. 시분할 시스템
		==> CPU는 한순간에는 오직 한개의 프로그램만 실행할 수 있다.
			하지만 여러개의 프로그램이 동시에 실행을 원한다면????
			한 순간에는 한개의 프로그램만 실행되고
			적당한 시간이 되면 그 프로그램은 보내고
			다른 프로그램을 받아서 실행하도록 하고있다.
			
			결론 ]
				각각의 프로그램마다 CPU가 실행할 시간을 정한 후
				그 시간만큼만 실행해준다.
			
	2. 우선순위(Priority)
		
		==> CPU는 시분할 시스템에 의해서 특정 프로그램을 자신이 분할한 시간만큼 실행한다.
			시간이 종료가 되면 다른 프로그램을 실행시켜야 한다.
			이때 CPU가 다음 프로그램을 선택하는 기준을 우리는 우선순위라고 말한다.
			
			좀 더 쉽게 말하자면 
			우선순위가 높은 프로그램이 CPU에 먼저 실행된다는 개념이다~!
			
---------------------------------------------------------------------------------------------------------
	
	자바에서 Thread 프로그램을 만드는 방법
		1. Thread 클래스를 상속받아서 만드는 방법
			1) Thread 클래스를 상속 받은 클래스를 제작한다.
			2) 그 클래스 안에 반드시
				run() 함수를
			   오버라이드 해놓는다.****
			   ( 이 함수가 프로세스 방식의 main()함수에 해당하는 것으로 스레드 프로그램의 시작함수가 된다.)
			3)  run() 함수부터 출발해서 그 프로그램이 하고자 하는 일을 코딩하면 된다.
			
		2. Runnable 인터페이스를 구현해서 만드는 방법
			1) Runnable 인터페이스를 구현하는 클래스를 제작한다.
			2) 그 클래스 안에 반드시 
					run() 함수를
			   오버라이드 해 놓는다.
			   ( 이 함수가 프로세스 방식의 main()함수에 해당하는 것으로 스레드 프로그램의 시작함수가 된다.)
			3) run() 함수부터 출발해서 그 프로그램이 하고자 하는 일을 코딩하면 된다.
			
	참고 ]
		둘 다 별 차이는 없지만
		상속은 오직 한개만 받을 수 있고		(단일 상속)
		구현은 여러개를 동시에 할 수 있다.	(다중 상속)
		따라서 상속을 받아서 스레드 처리를 하게 되는 순간
		다른 클래스는 상속받을 수 없는 상태가 된다.
		따라서 다른 클래스를 필요로 하는 경우를 대비해서 
		인터페이스 구현 방식도 제공하고있다.
		
	참고 ]
		Runnable 상태 : 
			==> CPU가 시분할 시스템에 의해서 프로그램을 선택할 때 
				선택 가능한 프로그램이 모여있는 상태
				
				**
				참고
					CPU는 Runnable 상태에 있는 프로그램만 실행할 수 있다.
				
			*****
			New Born 상태를 Runnable 상태로 전위(위치를 바꿔주는) 시키는 명령
				 start();
				 
		참고 ]
			실행함수가 run 함수이므로
			직접 run() 를 호출하면 이것은 스레드 동작이 아니고
			프로세스에서 함수 하나를 호출한 형태가 된다.
			(병행처리가 되지 않는다.)
			
		Run 상태    ::Runnable (교재에 있는 걸로 예제를 꼭 해볼것..)
			==> CPU가 특정 프로그램을 실제로 실행하는 상태를 말한다.
				Run 상태에는 오직 한개의 프로그램만 들어갈 수 있다.
				
				그리고
					Runnable ----> Run 상태로의 전위는
				(개발자가 할 수 없고)
				오직 운영체제가 해야 할 몫이다.
				( 한 마디로 개발자가 직접 손 댈수 없는 부분이다.)
				
			참고 ]
			  Run ---> Runnable 상태로의 전위는 
			  		1.	운영체제의 몫
			  		 	(==> 시분할 시스템에 의해서 시간이 만료된 시점)
			  		2.	개발자가 직접 선택할 수 있다. -- > yield 시스템
							( yield 명령은 개발자가 직접 해줄 수 있다. 또한 시분할 시스템이 해줄 수 도 있다.)
					
	참고 ]
		스레드 프로그램이 필요한 이유 ??
			1. 독립적으로 실행이 필요한 경우
				예 ]
					서버 프로그램에서는
					각각의 클라이언트와 통신하는 프로그램이 독립적으로 실행되어야 한다.
					즉, 클라이언트와 통신은 다른 작업과 별개로( 독립적으로 ) 실행되어야 할 필요가 있다.
			
			2. 백그라운드 작업이 필요한 경우
				예 ]
					 채팅 중 파일 업로드를 하는 경우
					 파일 업로드는 백그라운드에서 채팅작업과는 무관하게 처리되어야 한다.
						 (파일 업로드와 채팅기능을 각각 독립적으로 실행하도록 한다.....)
		스레드 프로그램을 동작시키는 방법
			1. Thread를 상속 받은 경우
				1) new 시킨다.		==> New Born 상태가 된다.
				2) start 시킨다. 	==> Runnable 상태로 전위된다.
			
			2. Runnable 인터페이스를 구현한 경우
				
				1) new 시킨다.		==> 일반 클래스를 사용하기 위한 객체지향 방법 ( Runnable 인터페이스 제작 => 다른 클래스도 상속 받을 수 있다)
				2) Thread 클래스를 New시키면서 1)의 결과를 넣어 준다.
						==> 이 순간 New Born상태가 된다.
				3) 2)의 결과를 이용해서 Start 시키면 된다.
					==> Start시키면 Runnable상태가 되겠다.(전위)
			
			
				 		class는 1번에 1개의 클래스만 상속받을 수 있다. Extends<
			interface (추상함수 구현 - 여러개 사용할 수 있음)
	Runnable 인터페이스가 만들어진 이유 : 다른 클래스를 상속받은 클래스에서 스레드를 사용하기 위해서...
			
참고 ]
	==> 하나의 스레드 프로그램은 여러번 실행할 수 있다.
		그러면 이들은 각각 독립적으로 실행된다.
			즉, 하나의 스레드처럼 여러개 ㄴ프로그램이 실행되어진다.
			
		스레드에 부여된 이름.....
		
		String name = Thread.currentThread().getName(); // 현재 실행되고 있는 스레드를 선택해준 다음, 그 스레드에 부여된 이름을 반환해준다.	  
		
		으로 받아서 사용할 수 있다.
				
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	1. Run ---> RUnnable로 전위시키는 명령
		
		yield()
		
	참고 ]
		Block 상태란 ???
			실행을 잠시 중단하는 상태를 말한다.
			Block상태에 있는 프로그램은 절대로 실행되지 않는다.ㄴ
			( 실행되는 애들은 반드시 Runnable에 있는 애들만 가능하다. )
			그리고 Block 상태에서 빠져나오는 방법은
			오직 Runnable 상태로 전위되는 것 뿐이다.
			따라서 Block 상태에서 직접 선택해서 실행할 수는 없다.
	
	2. Run ---> Block 상태로 전위시키는 명령은 
		
		sleep(시간)
			==> 이 명령은 시간을 정해주고
				그 시간이 되면 자동적으로 Runnable상태로 복귀 시키는 명령

스레드가 있는 프로그램 종료
	일반적으로 스레드가 존재하지 않는 프로세스 프로그램은 
		main()이 종료되면 프로그램도 종료가 된다.
	하지만 스레드가 존재하는 프로그램은
		1. main() 도 종료되고 
		2. 스레드도 종료되어야 한다.
	두 가지가 모두 만족되어야 프로그램이 종료된다.
	
	1. 스레드를 강제로 종료하는 방법
		
		명령어 : 
				java.lang.Thread
				stop()
				==> 이 함수는 Deplecated 되어있어서 사용금지 명령
					
		참고 ]
			하지만 자바측에서는 이 함수를 사용금지 함수로 만들었다.
			대신 스레드를 종료하기 위해서는
			스레드가 스스로 종료되는 방향으로 프로그램을 제작해서
			프로그램이 종료될 수 있도록	처리하도록 한다.
			즉, run()가 자연스럽게 종료되도록 처리하라는 말이다.
			
		참고 ]
			main() 가 종료되면 프로세스 프로그램이 종료되듯이
			run() 가 종료되면 스레드 프로그램도 종료된다.
			
		정리 ]
			run() 는 제어 변수를 이용해서 반복하도록 처리한다.
			
			while(isStart){
				처리내용
			}
			그리고 스레드가 종료될 필요가 있으면 이 제어 변수를 조작함으로써 run()가 종료되도록 유도한다.
				isStart = false;
				
	참고 ] 
		한번 Death된 스레드는 다시는 실행하지 못한다.
		만약 재실행을 원하면
		New Born부터 다시 시작해야 한다.
	
	일시중지 하기
		명령 ]
			suspend()
		
	재실행하기
		명령 ]
			resume()
	
	위 두가지 함수 모두 사용 금지 함수이다.
	대신 동기화를 사용해서- 처리하도록 해놓았다.

자기자신을 Block 으로 만드는 방법
	1. sleep(시간)
		==> 지정한 시간동안 스스로 Block 상태로 만드는 명령
	2. join()
		==> 다른 스레드가 종료되기 전까지는 스스로
			Block 상태로 만드는 명령
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
동기화 처리
	==> 스레드의 장점은 메모리를 공유한다는 사실이다.
		그런데 이것이 엄청나게 어려운 내용이다
		왜냐하면 스레드가 어디까지 실행할지는 모르기 때문이다.
		
	동기화란???
		특정 스레드가 어디까지 실행할지를 묶어두는 기능을 동기화라 한다.
		
	종류 ]
		1. 변수 동기화
			==> 스레드가 특정 기능을 마칠때까지 그 변수를 다른 스레드가 사용하지 못하도록 방지하는 방법이다.
				
				형식 ] 
					synchronized(변수){
					
					}
				의미 ]
					하나의 스레드가 블럭{}안을 모두 실행하는 도중에는
					다른 스레드가 이 변수를 사용하지 못하도록 막는다.
					 ==> 동기화~이다. (사용한다는 ? 안에있는 데이터를 교체한다 라는 뜻.. 그럼 프로그램이 이상해지기 때문에!)
					 
		2. 함수 동기화
			==> 스레드가 특정함수를 실행하는 도중에는
				다른 스레드는 그 함수를 사용하지 못하도록 방지하는 방법이다.
				
			형식 ]
				// 함수를 만들 때 이렇게 만들어 버리자~ 라는 것.
				synchronized 반환값 함수이름(매개변수리스트){
				
				}
			의미 ]
				하나의 스레드가 이 함수를 실행하는 도중에는
				다른 스레드는 이 함수를 사용할 수 없다.
				
		참고 ]
			동기화는 항상 성립하는 것이 아니다.
			두개 이상의 스레드가 변수나 함수를 공용으로 사용할 경우에만 성립하는 것이다.
			(두개 이상의 변수나 함수 사용하지 않는데 동기화처리 할 필요가 없기 때문이다, 스레드가 하나뿐인데 동기화 해줄 이유도 없기 때문이다.)
			
			만약 두 스레드가 별개의 함수나 변수를 사용하면
			이것은 동기화 처리를 해도 영향을 받지 않는다.
			
	참고 ]
		보통 2개 이상의 스레드를 만든다는 개념은
		두개가 같은일을 할 수도 있지만
		대부분은 별도로 다른일을 동시에 하기위해서 만들것이다.
		이 때 서로가 공유데이터가 존재하면 문제가 생길 수 있다.
		
		하지만 앞의 동기화 문제점은
		한 쪽 스레드가 하나의 작업을 완료하기 전에는
		다른 스레드는 작업하지 못하고 대기해야 한다.
		이것은 엄밀히 말하면 스레드의 효과가 없다는 말이다.
		
	따라서 서로가 병행처리를 하면서 공유 데이터를 손상시키지 않도록 하는 방법
	
		규칙 ]
			1. 특정 스레드가 작업을 해서는 안될 시점이 되면
				스스로 Block 상태로 전위되도록 해야한다.
					
					wait()
				이라는 함수를 사용한다.
				
			2. 다른 스레드 입장에서는
				상대방 스레드가 일을 해도 좋은 시점이 되면 깨워준다.
				==> Runnable 상태로 복귀시킨다.
					
					notify()
				라는 함수로 Runnable 상태로 전위시킬 수 있다.
				
		*****
		wait() 이나 notify()는 반.드.시 동기화 함수 안에서만 사용해야 한다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

상호참조 ( 클래스 통신 )
	==> 일반적으로 프로그램을 제작하는 경우 하나의 클래스가 다른클래스를 일방적으로 참조하는 방식으로 처리를 하는데
		두 개 의 클래스가 서로 상대방의 멤버(변수와 함수)를 사용 할 수 있도록 하는 방법
		
	상호참조의 규칙]
		1. 먼저 실행되는 클래스에서는 다른 클래스를 new 시키면된다.
		2. 나중에 실행되는 클래스는 먼저 실행된 클래스를 new 시키면 안된다.
		
		new 시킬 때 생성자함수에서 (실행되고 있는 클래스 자기 자신을 상대 클래스에서 참조할 수 있을거다)
		
		3. 대신 만들어진 클래스의 주소(this)를 받아서 그대로 기억하면 된다.
		
		예 ]
			
			class Thst1{
				public Test1(){
					  Test2 t2 = new Test2(this);
			  }
		  
		  }
		  
		  class Test2{
		  	
		  	public Test2(){ 
		  	public Test2(Test1 main{
		  	this.main = main;
		  	
		  }
	
	
				
				
			
				
	