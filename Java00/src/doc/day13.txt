#day13

다형성의 이해]

		A라는 클래스가 있고
		A라는 클래스를 extends한 B라는 클래스가있고
		B extends C,
		C extends D.
		
		A a = new D();
		B a = new D();
		C a = new D();
		D 인스턴스는 A,B,C 모두 포함되어있기 때문에 사용 가능하다.
		A a = new D();
----------
extends Z{xyz();}
하위 :X	Y	W    << 모두 xyz(); 를 갖고있음. 그러므로 X, Y, W 클래스는 Z라고 볼 수 있다.
	
	W{xyz(); abc();}  <<abx();가 추가 되어도 xyz();만 있으면 Z라고 볼 수 있다.
	
	Y{xyz(); xyg();} << xyz();가 있으므로 Z라고 볼 수 있다.
	
	X{xyz(); lmn();} << 마찬가지로 xyz();가 있으므로 Z라고 볼 수 있다.
	
	∴ X, Y, W is Z (X, Y, W 는 Z 다)로 말할 수 있다.

함수는 인스턴스<제일마지막 오버라이딩 한 함수를 따른다.>
변수는 레퍼런스<처음 초기화되어있는 변수를 따른다.>

ERD처럼 처음 기본키를 지정해놓는 함수를 만들어놓고
그 외 오버라이딩을 할 클래스를 트리다이어그램으로 제작해 놓고
 세부적인 역할을 하는 키들은 기본키를 기준으로 수정해 나간다.
 
예를 들면
	기본키는 커서 모양이 바뀌는 클릭 가능한 버튼버튼이고
	오버라이딩한 세부조작 키는 끄기, 닫기, 다시시작, 취소 .. 등등 여러 기능을 만들어 놓게 된다. 
-----------------------------------------------------------------------------------------------------------------

클래스 블럭 : 클래스가 갖고있는 것을 정의하는 것.

함수 블럭 : 기능을 처리하는 것을 정의하는 것. : 함수블럭이 없다 = 기능이 아직 정의되지 않았다.
		==> 함수에 블럭이 없다 : 상속받아 Overriding 해서 사용해라 라는 뜻으로도 볼 수 있다.
			이런 함수를 추상 함수 abstract 함수();
			
	==> 클래스중에 추상함수를 하나라도 갖고있는 클래스는, 추상 클래스라고 한다.
	
	***
	추상 클래스는 new 시킬 수 없습니다. ==> 아직 정의가 되지 않은 멤버가 있기 때문에 메모리에 올릴 수 없다.
		==> 이 클래스들을 사용할 때 ?? 상속 받아서 사용해야 한다.
			추상 클래스를 상속받으면, 추상함수를 오버라이딩 한다는 의미가 된다. 그 후 new시킬 수 있는 클래스로 바뀌게 된다.
				==> 상속받은 인스턴스의 오버라이딩 된 경우 상속한 클래스의 추상함수를 실행시킬 수 있다.
		결론]
			추상클래스는 상속받은 하위 클래스에서 추상함수를 Overriding을 한 후 추상클래스를 사용할 수 있게 된다.
-----------------------------------------------------------------------------------------------------
			 
# 추상클래스
	==> 추상함수를 0개이상 가지고 있는 클래스
		
		추상 함수가 한개도 없다하여도 강제로 추상 클래스를 만들 수 있고
		추상 함수가 한개라도 있으면 반드시 추상 클래스를 만들어야 한다.
		
		추상함수란??
			
			==> 함수의 몸체({})가 없는 함수를 말한다.
				즉, 기능이 없는 함수를 말한다.
				--> C언어에서는 가상 함수에 해당.
				
			형식 ]
				[접근 지정자]	abstract	반환값 타입 함수이름(매개변수리스트);
				
			예 ]
				public abstract void abc(int a);
				
추상 클래스를 만드는 방법:
	형식]
		
		[접근 지정자] abstract class 클래스이름{
			변수
			일반 함수
			[추상 함수] 
		}
	
	만들어진 이유]
		다형성 구현을 위해서 ...
		
--------------------------------------------------------------------------
	
	추상 클래스 사용하는 방법
		==> 추상 클래스는 스스로 new 시킬 수 없다.
			// 생성자 함수가 있긴 하지만 abstract 속성이 붙어있으면 객체로 만들 수 없다.
			왜냐하면 그 클래스 안에는 아직 완성되지 않은 함수가 존재하기 때문이다.
			
			사용 방법 ]
				
				1. 다른 클래스에 상속을 한 후 추상 함수의 기능을 만들어주고(Overriding하고)
					하위 클래스를 new 시켜서 사용하면 된다.
					==> 이 경우. 즉, api를 사용하는 경우는 10%미만이다...
					  
				2. 추상 클래스 내부에
					속성이 static이면서 
					반환값이  자신을 반환해주는 함수가 존재한다.
					그런 함수를 사용하면 된다.
					
			예 ]
				Calendar 클래스의 getInstance();
				
				반환값 : static Calendar 
		
		참고]
			
			 추상 클래스가 아님에도 생성자 함수가 존재하지 않는 클래스가 있다.
			또는 생성자 함수의 접근지정자를 private로 정의 해놓은 클래스가 있다.
			이런 클래스 역시 new 시켜서 객체를 만들어서 사용할 수 없다.
			
			이때도 역시
				속성이 static이면서
				반환값이 자기 자신인 함수를 찾아서 사용하면 된다.
-------------------------------------------------------------------------------

문제 1]
	
	Figure 클래스를 상속 받아서 Nemo, Semo, Won 클래스를 작성하세요.
	Figure 클래스는 면적을 구해주는 추상함수만 멤버로 가지고 있습니다.
	
	ArrayList에 각 도형의 인스턴스를 10개 랜덤하게 담고
	꺼내서 출력하는 프로그램을 작성하세요.
-------------------------------------------------------------------------------

인터페이스( Interface )
==> 클래스의 한 종류이긴 하지만 그 형태나 의미가
	지금까지 사용했던 클래스하고는 다른
		특수한 클래스의 일종이다.
		
	1. 최상위 클래스가 Object가 아니다.
		==> 즉, 인터페이스는 다른 클래스를 상속 받아서 만들어진 클래스가 아니다.
	
	2. 내부에는 100% 추상함수만 존재해야 한다.
		==> 절대로 일반 함수는 존재하지 않는다.
			==> 기능을 가진 함수가 존재하면 안된다는 의미다.
		
		참고 ]
		
			인터페이스 내부에 선언되는 함수는
			따로 정의 하지 않아도 자동적으로
				public 접근지정자와
				abstract 속성이 부여가 된다.
				
	3. 인터페이스는 다른 클래스에 상속해줄 수 있는데
		다중 상속이 가능하다.
			
	4. 변수는 가질 수 있다.
		이때 따로 선언하지 않아도 자동적으로
		
			public static final
			
		이 붙게 된다.
	
	5. 인터페이스 소속 함수는 묵시적으로 public함수가 된다.
	
인터페이스 만드는 방법 ]

	[접근지정자] interface 인터페이스이름 {
		변수 	==> 자동적으로 public static final 변수가 된다.
		함수	==> 자동적으로 public abstract 함수가 된다.
	}
	
왜 인터페이스를 만들었나요??
	
	==>  가끔은 JVM에 의해 자동 호출되어야하는 함수가 필요하다.
		따라서 함수의 존재는 필요하다.
		하지만 가끔은 이 함수가 해야할 일을 정할 수 없는 경우가 있다.
		이 때는 그 함수의 정의는 개발자의 몫으로 넘겨야 하는 경우겠다.
		
	==> 결국 인터페이스도 다형성 구현을 위해서 만들어졌다.
		// 안의 함수들 따로 정의해서 interface에 담게되면 함수만 호출해서 실행하면 된다.
											*일반함수는 사용할 수없다~.
	
인터페이스 사용하기

	1. 인터페이스는 스스로 new 될 수 없다.
		이유는 추상클래스와 마찬가지로 추상함수를 가지고 있기 때문이다.
		
		(1)
			따라서 사용할 때는 일반 클래스에 상속해준 후 사용해야 한다.
			
			상속(구현) 방법 ]
							: implements, 구현하다 ==> 정의만 된 개념을 실체화시키다.
				class 클래스이름 implements 인터페이스 이름{
					추상함수 오버라이딩; // <<-- 반드시, 추상함수 오버라이딩을 해야한다.
				}
				
			참고 ]
				일반 클래스를 상속 받는 것은 상속이라고 표현하고		:	extends : 상속시키다
				인터페이스를 상속 받는 것은 구현이라고 표현한다. 	:	interface의 implements : 구현하다. 
			
		(2)
			상속 받은 클래스에서는 인터페이스 내부에 있는 함수(추상함수)를
			100% 오버라이드 해야 한다.
			그리고 필요한 기능은 개발자가 구현하면 된다.
			==> 따라서 인터페이스 소속의 함수는 public 이다.
		
		(3)
			일반 클래스를 new 시켜서 사용한다.
			==> 인터페이스 타입의 변수에 상속받은 클래스의 인스턴스를 기억시킬 수 있다.
			
	참고 ]
		가끔은 속성이 static 이면서 반환값이 자기자신인 함수가 있어서 그 함수를 호출해서 //> 추상클래스 인스턴스 만들 때 사용 되었다.
		사용하는 경우도 있다.
		그런데 인터페이스에는 기능을 가지는 함수가 존재할 수 없으므로 다른클래스의 멤버중 이런 함수를 찾아서 사용해야 한다.
	
	참고 ]
		인터페이스는 다중 상속이 가능하다.
		
		형식 ]
			
			class 클래스이름 implements 인터페이스1, 인터페이스2, ...{
			
			}
			
		주의사항]
			이 경우는 상속해준 인터페이스의 모든 소속 함수를 100% 오버라이딩 해야 한다.
	
	참고 ]
		일반 상속과 구현은 같이 사용할 수 있다.
		
		형식 ]
			
			class 클래스이름 extends	상속해줄클래스 implements 인터페이스1, 인터페이스2,...{
			
			}
			
		주의 ]
			
			반드시 extends가 먼저 와야하고
			implements가 나중에 와야 한다.
			
	참고 ]
		인터페이스도 다른 인터페이스를 상속받아서 만들 수 있다.
		interface 인터페이스이름 extends 인터페이스 {
		}
		
	주의 사항 ]
		
		인터페이스가 인터페이스를 상속받는 경우는
			extends
		를 사용해야 한다.
	
	참고 ]
		
		인터페이스 안에도 일반 함수가 존재 할 수 있다.
		이 경우에는 반드시 함수의 속성을 default 라고 명시해야 한다.
		
		형식 ]
			
			default 반환값타입 함수이름 (매개변수리스트){
				함수 내용;
			}
			// 이 default 함수는 인터페이스를 상속받았을 때 오버라이딩을 하지 않아도 된다.
			
========================================================================================

HomeWork ]
	
	day13.sub.Moyang 인터페이스를
	같은 패키지내에서 구현한 사각형, 동그라미 클래스를 만들고
	추상함수 문제처럼 ArrayList에 랜덤하게 10개를 담아서
	내용을 출력하는 프로그램을 작성하세요.
========================================================================================
내부 클래스
	==> 클래스 안에 만들어지는 클래스를 내부 클래스라고 한다.
	
	종류 ]
		
		1. Top Level Inner Class
			==> 형식은 내부 클래스이지만 독립적으로 활동하는 클래스 이다.
			
			형식 ]
				
				static class 클래스이름 {}
				
				내부에 만들면서  static 이 붙으면 Top Level Inner Class가 된다.
				
			==>
				일반 클래스와 달리 내부 클래스의 이름은
					바깥클래스.내부클래스 
				 의 형식을 취한다.
		*****					 
		2. 전역 Inner Class
			==> 일반 클래스를 내부클래스로 만든 것
				따라서 이 클래스가  내부클래스라고 부르는 것.
				
			형식 ]
				class 클래스이름{
				}
			
			특징 ]
				1. 바깐 클래스의 모든 멤버는
					저절로 자기멤버처럼 사용할 수 있다.
				2.	반드시 바깥 클래스가 new 된 이후에 안쪽클래스를	셍성할 수 있다.
					// new 시킬 수 있다는건 객체로써 이용할 수 있다.
				
			 		형식]
			 			바깥클래스주소.new 안쪽클래스이름();
			 	3.  바깥 클래스는 안쪽 클래스의 멤버르 사용할 수 없고
					사용하기를 우너하면 new 시켜서 사용해야 한다.
			
		주고 바깥클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 많이 사용하는 방법
				 	
				3. 지역 Inner Class
					==> 내부 클래스를 만드는 위치가 바깥 클래스의 함수 내부에서 만들어지는 클래스
					
					class Test {
						int a;
						
						class Inner(){ // 전역 Inner Class
						}
						void abc(){
							int b;
							class Inner{} // 지역 inner Class
					}
					
					특징 ]
						1. 전역 Inner Class와 유사하게 바깥 클래스의 멤버를 사용할 수 있다.
						2. 다른곳에서 new 시킬 수 없다.
							오직 해당 함수 안에서만 new 시킬 수 있다.
							
				4. 무명(익명) Inner Class
			
				==> 말 그대로 이름이 없는 클래스를 말한다.
					
					우리가 프로그램을 만들다보면
					클래스의 기능수정을 위해서 오버라이딩을 해야할 경우가 발생한다.
					(어쩔 수 없이 오버라이드 해야하는 경우도 있고..'추상함수들')
					
					이 때 원칙적으로는
						다른 클래스를 만들고 그 클래스에 필요한 클래스를 상속한 후
						오버라이드를 해야 한다.
						
						이 때 간단한 내용을 오버라이드 해야 하는 경우 
						그 기능 하나 때문에 클래스를 따로 만들어야 하는 
						불편한 상황이 발생할 수 있다.현
					
					따라서 이런 경우를 위해서 만들어서 사용하는 클래스로
					클래스를 new 시키는 순간 필요한 기능을 오버라이드해서 사용하는 방법이다.
					
					즉, 사용자가 클래스 이름을 만들지 않아도 된다...
					라는 의미에서 무명(익명)이라고 부른다.
					
					형식]
						new 클래스이름 (){} << 추상함수들을 구 해주면 된다.
