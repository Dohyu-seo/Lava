#day14

Quiz ]
	예외처리의 목적은?
	==> 프로그램의 정상적인 종료 ...
	
예외처리
	==> 프로그래램적으로는 문제가 없으나( <== 문법상 오류가 없으나..)
		데이터의 문제나 장비의 문제 등에 의해서 프래그램을 실행하는 도중 발생하는 에러를
			"실행 에러(Run Time Error)" 라고 표현하고
		이것을 자바에서는 "예외 (Exception)" 이라고 부른다.
		
		문제는
		 이런 예외는 개발자가 예측해서 이런 문제가 발생했을 경우 대처하는 방식으로 프로그램을 제작해야한다. 
		  이처럼 예외가 발생했을 경우 대처하는 방식의 프로그램을
		 	"예외처리"
		 라고 한다.
		
	자바에서는 이런 문제점(예외가 발생하는 원인을 개발자가 알고있어야 한다)
	을 문제점을 해결 하기 위해서 예외처리 문법이 존재한다
	
	형식]
		
		(1)
		try{
			(2)
			실행문
			(3)
		} catch(#####){
			(4)
		} finally{
			(5)
		}
		(6)
		
		실행순서 ]
				
			실행문이 에러가 안날 경우  : 1 -> 2 -> 3 -> 5 -> 6
			실행문이 에러가 날 경우	 : 1 -> 2 -> 4 -> 5 -> 6 
			
	문제점 ]
		(3)번이 문제인데
		이 부분에 있는 내용은 예외가 발생하면 실행되지 않는다.
		따라서 try 블록에 있는 범위에 따라서 실행 할 수 있고 실행되지 않을 수도 있다.
	
		예 1]
		
		try {
			파일을 오픈하고 ==> 파일이 없으면 에러가 난다.
		} 
			
			파일 내용을 읽는 명령 ==> 이 경우 파일의 오픈 여부에 따라서 읽는 명령도 실행 여부가 판단이 되므로
								다시 에러가 발생할 수 있다.
// 그러므로 파일 내용 읽는건 try에 같이 넣는게 효율적일지 모른다.
		
		
		예 2]
		
			try{					-1
				while(true){
					tyr{			-2
						클라이언트에 접속을 받는 명령 ==> 클라이언트의 문제로 예외가 발생할 수 있다.
						 
					} 					2 클레이언트의 접속을 받는다.
				}
			}							1 여기서 블럭이 종료가 되면, 다시 클라이언트의 접속을 받지 않는다.
												
												
	자바의 예외처리의 원리
		예외가 발생하면 JVM은 발생한 예외의 종류를 분석한 후
		예외에 대한 정보를 자바스럽게 클래스로 만들어서
		catch 부분에 그 클래스의 주소를 전달해 준다.
		
	catch의 의미는 
		==> 예외가 발생하면 그 예외의 정보를 받아서
			개발자가 그 정보를 이용해서 원하는 처리를 해 줘야 한다.
			
	그런데, catch는 다중으로 쓸 수 있습니다.
	
	다중 catch (참고로 if - else if - else 구문 참고)
		==> 
			try{} 안에 여러명행들이 여러가지 복합적으로 예외 발생 요소를 가질 수 있다.
			
			이 때 반드시 어떤 에러 때문인지를 구분해야 한다면?
			이런 경우를 대비해서 만들어 놓은 방법이다. (다중 catch 구문)
			
		형식]
			try{
			
			} catch( 예외처리 문 ){ 
			
			} catch( 예외처리 문 ){ 
			
			} catch( 예외처리 문 ){ 
			
			}
			
		주의 사항 ]
			다중 catch를 사용하는 경우
			반드시 실행 될 수 있는 상태로 만들어야 한다.
				==> 예외의 범위가 좁은 쪽부터 써야한다. 넓은 범위의 예외처리는 큰 카테고리에 포함시켜 예외처리의 세분화 시키는 기능을 상실하게 된다.
--------------------------------------------------------------------------------------------------------
문제 1]
	
	if - else if 구문을 사용해서
	
	나이를 입력하면 십대, 이십대,... 
	판별해주는 프로그램을 작성하세요.
--------------------------------------------------------------------------------------------------------

finally  블럭
	==> 예외 발생 여부에 관계 없이 반드시 실행되어야 할 명령이 존재할 경우 
		이런 문장들을 입력하는 블럭이다.
	
	참고 ]
		만약 finally 블럭이 존재한다면 catch 블럭을 생략해도 무방하다.
		 (실제 실무에서는 catch 블럭을 생략하지 않는다.)

예외 정보 출력하기 
	==> 다음 이유에 의해서 예외정보를 얻을 수 있다.
		
		1. 예외정보 클래스의 변수를 출력하면 된다.
			예 ]
			 System.out.println(예외정보 클래스 변수);
			 ==> 예외의 원인을 파악할 수 있게 된다.
			 
		2. 변수.printStackTrace() 를 이용하는 방법
			==> 예외의 정보 
				+ 예외가 발생하게 된 위치와 경로를 추적해서
					출력해준다.
		
	우리가 앞에서 예외처리는
	예외가 발생하면 개발자가 그것을 수정해서 정상적으로 동작하도록 만드는 행위라고 정의했다.
	하지만 정상적으로 동작하도록 만드는 행위를 한다는 것은
	매우 어려운 일이며, 그 경우는 많지 않다
	
	다만 예외를 하는 실제 이유는
	예외 정보를 알아서 사용자에게 왜 프로그램에 문제가 생겼는지를 알려주고
	그 프로그램이 정상적으로 종료되도록 하는 것이 목적으로 갖는 경우가 많다.

--------------------------------------------------------------------------------------------
(예외 처리 만드는법은 교재 활용하기)

예외 전이하기
	==> 함수는 프로그램의 가장 작은 단위로 한가지 작업을 하기 위해서 만드는 것.
		따라서 함수 안에서 작업을 하다가 예외가 발생하면
		그 함수는 더이상 실행할 필요가 없는 경우가 많다.
				// 예외가 발생한 경우, 그 함수는 쓰지 못하게 된 것이다. 그 예외가 발생한 곳을 다른 처리하는 부분으로 옮기는 것.
		따라서 함수는 예외를 전이하도록 해놓은 경우가 있다.
		
		형식]
			
			[접근지정자] [속성] 데이터타입	함수이름(매개변수리스트) throws 예외클래스1, 예외클래스2, ...{
			
			}
			
		의미]
			지정한 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로 실행을 중지시킨다.
			
		*****
		예외가 전이된 함수는
		 그 함수를 사용하는 곳에서 반드시 예외 처리를 해 주어야 합니다.
		 
		 참고 ]
		 	==> 어떤 함수가 예외를 전이하는 함수라도
		 		예외처리를 하지 않아도 되는 경우가 있다.
		 		
		 		전이하는 예외가 RuntimeException의 하위인 경우에는 예외처리를 해도 그만, 안해도 그만 이다.
		 		(주로 java.lang 패키지 소속 클래스에 있는 함수들이 이런 형태들이 많이 존재한다.)
		 			하지만 될 수 있으면 해주는 것이 좋다.
------------------------------------------------------------------------------------------------

Object 클래스
	==> 자바로 만든 클래스의 최상위 클래스 역할을 하는 클래스
		솔직히 말해 하는일은 별로 없고
		자바 상속 관계를 명확하게 하기 위한 역할을 주로 하는 클래스
		
	1. equals()
								String = equals() <== 데이터 자체를 비교합니다, ' == ' 는 주소만 비교하게 된다.
		==> 비교 함수 이다.
			문제는 Object가 가지고 있는 이 함수는
			내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
		
		참고 ]
			우리가 String 클래스의 equals 함수를 사용해서 문자열 데이터를 비교를 해서
			이 함수를 내용 비교함수로 알고있는데
			이것은 String 클래스가 Object 클래스의 equals 함수를 오버라이드해서
			기능을 내용 비교로 변경시켜서 사용하는 함수로 만들어 놓은 것이다.
			따라서
				Object.equals() 와 Stirng.equals()의 차이점을 명확하게 구분해야 할 것이다.
			
		참고 ]
			만약 우리가 만드는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드해서 기능을 수정하면 될 것이다.	
------------------------------------------------------------------------------------------------

문제 2]
	삼각형 클래스를 작성하고
	
	삼각형 클래스의 밑변과 높이를 입력해서 객체를 만들도록 작성하고
	만약
		밑변이 같으면 같은 삼각형이 되도록
	equals함수, toString()을 오버라이드하고
	테스트 하세요.
	
	입력, 출력 은 JOptionPane소속으로 한다.
	
	추가로 예외처리도 해주세요.
	